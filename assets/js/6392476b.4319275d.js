"use strict";(self.webpackChunksite=self.webpackChunksite||[]).push([[860],{5680:(e,t,a)=>{a.d(t,{xA:()=>u,yg:()=>m});var n=a(6540);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,n,o=function(e,t){if(null==e)return{};var a,n,o={},l=Object.keys(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||(o[a]=e[a]);return o}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var s=n.createContext({}),p=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},u=function(e){var t=p(e.components);return n.createElement(s.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},g=n.forwardRef((function(e,t){var a=e.components,o=e.mdxType,l=e.originalType,s=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),c=p(a),g=o,m=c["".concat(s,".").concat(g)]||c[g]||d[g]||l;return a?n.createElement(m,r(r({ref:t},u),{},{components:a})):n.createElement(m,r({ref:t},u))}));function m(e,t){var a=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var l=a.length,r=new Array(l);r[0]=g;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i[c]="string"==typeof e?e:o,r[1]=i;for(var p=2;p<l;p++)r[p]=a[p];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}g.displayName="MDXCreateElement"},9365:(e,t,a)=>{a.d(t,{A:()=>r});var n=a(6540),o=a(53);const l={tabItem:"tabItem_Ymn6"};function r(e){let{children:t,hidden:a,className:r}=e;return n.createElement("div",{role:"tabpanel",className:(0,o.A)(l.tabItem,r),hidden:a},t)}},1470:(e,t,a)=>{a.d(t,{A:()=>x});var n=a(8168),o=a(6540),l=a(53),r=a(3104),i=a(6347),s=a(7485),p=a(1682),u=a(9466);function c(e){return function(e){return o.Children.map(e,(e=>{if(!e||(0,o.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}(e).map((e=>{let{props:{value:t,label:a,attributes:n,default:o}}=e;return{value:t,label:a,attributes:n,default:o}}))}function d(e){const{values:t,children:a}=e;return(0,o.useMemo)((()=>{const e=t??c(a);return function(e){const t=(0,p.X)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,a])}function g(e){let{value:t,tabValues:a}=e;return a.some((e=>e.value===t))}function m(e){let{queryString:t=!1,groupId:a}=e;const n=(0,i.W6)(),l=function(e){let{queryString:t=!1,groupId:a}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!a)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return a??null}({queryString:t,groupId:a});return[(0,s.aZ)(l),(0,o.useCallback)((e=>{if(!l)return;const t=new URLSearchParams(n.location.search);t.set(l,e),n.replace({...n.location,search:t.toString()})}),[l,n])]}function _(e){const{defaultValue:t,queryString:a=!1,groupId:n}=e,l=d(e),[r,i]=(0,o.useState)((()=>function(e){let{defaultValue:t,tabValues:a}=e;if(0===a.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!g({value:t,tabValues:a}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${a.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const n=a.find((e=>e.default))??a[0];if(!n)throw new Error("Unexpected error: 0 tabValues");return n.value}({defaultValue:t,tabValues:l}))),[s,p]=m({queryString:a,groupId:n}),[c,_]=function(e){let{groupId:t}=e;const a=function(e){return e?`docusaurus.tab.${e}`:null}(t),[n,l]=(0,u.Dv)(a);return[n,(0,o.useCallback)((e=>{a&&l.set(e)}),[a,l])]}({groupId:n}),v=(()=>{const e=s??c;return g({value:e,tabValues:l})?e:null})();(0,o.useLayoutEffect)((()=>{v&&i(v)}),[v]);return{selectedValue:r,selectValue:(0,o.useCallback)((e=>{if(!g({value:e,tabValues:l}))throw new Error(`Can't select invalid tab value=${e}`);i(e),p(e),_(e)}),[p,_,l]),tabValues:l}}var v=a(2303);const f={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function y(e){let{className:t,block:a,selectedValue:i,selectValue:s,tabValues:p}=e;const u=[],{blockElementScrollPositionUntilNextRender:c}=(0,r.a_)(),d=e=>{const t=e.currentTarget,a=u.indexOf(t),n=p[a].value;n!==i&&(c(t),s(n))},g=e=>{let t=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const a=u.indexOf(e.currentTarget)+1;t=u[a]??u[0];break}case"ArrowLeft":{const a=u.indexOf(e.currentTarget)-1;t=u[a]??u[u.length-1];break}}t?.focus()};return o.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,l.A)("tabs",{"tabs--block":a},t)},p.map((e=>{let{value:t,label:a,attributes:r}=e;return o.createElement("li",(0,n.A)({role:"tab",tabIndex:i===t?0:-1,"aria-selected":i===t,key:t,ref:e=>u.push(e),onKeyDown:g,onClick:d},r,{className:(0,l.A)("tabs__item",f.tabItem,r?.className,{"tabs__item--active":i===t})}),a??t)})))}function h(e){let{lazy:t,children:a,selectedValue:n}=e;const l=(Array.isArray(a)?a:[a]).filter(Boolean);if(t){const e=l.find((e=>e.props.value===n));return e?(0,o.cloneElement)(e,{className:"margin-top--md"}):null}return o.createElement("div",{className:"margin-top--md"},l.map(((e,t)=>(0,o.cloneElement)(e,{key:t,hidden:e.props.value!==n}))))}function b(e){const t=_(e);return o.createElement("div",{className:(0,l.A)("tabs-container",f.tabList)},o.createElement(y,(0,n.A)({},e,t)),o.createElement(h,(0,n.A)({},e,t)))}function x(e){const t=(0,v.A)();return o.createElement(b,(0,n.A)({key:String(t)},e))}},4546:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>u,contentTitle:()=>s,default:()=>m,frontMatter:()=>i,metadata:()=>p,toc:()=>c});var n=a(8168),o=(a(6540),a(5680)),l=a(1470),r=a(9365);const i={sidebar_position:1,sidebar_label:"Autonomous Functions",title:"Autonomous Functions"},s=void 0,p={unversionedId:"docs/autonomous-functions",id:"docs/autonomous-functions",title:"Autonomous Functions",description:"JAR Template provides a multitude of ways to control the chassis using PID and odometry.",source:"@site/docs/docs/autonomous-functions.md",sourceDirName:"docs",slug:"/docs/autonomous-functions",permalink:"/JAR-Template/docs/autonomous-functions",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,sidebar_label:"Autonomous Functions",title:"Autonomous Functions"},sidebar:"tutorialSidebar",previous:{title:"Docs",permalink:"/JAR-Template/docs/"},next:{title:"Drive Class",permalink:"/JAR-Template/docs/drive-class/"}},u={},c=[{value:"Non-Odometry Functions",id:"non-odometry-functions",level:2},{value:"turn_to_angle();",id:"turn_to_angle",level:3},{value:"drive_distance();",id:"drive_distance",level:3},{value:"left_swing_to_angle();",id:"left_swing_to_angle",level:3},{value:"right_swing_to_angle();",id:"right_swing_to_angle",level:3},{value:"Odometry Functions",id:"odometry-functions",level:2},{value:"drive_to_point();",id:"drive_to_point",level:3},{value:"turn_to_point();",id:"turn_to_point",level:3},{value:"holonomic_drive_to_point();",id:"holonomic_drive_to_point",level:3}],d={toc:c},g="wrapper";function m(e){let{components:t,...a}=e;return(0,o.yg)(g,(0,n.A)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,o.yg)("p",null,"JAR Template provides a multitude of ways to control the chassis using PID and odometry."),(0,o.yg)("admonition",{type:"note"},(0,o.yg)("p",{parentName:"admonition"},'Each movement function includes a basic and an advanced prototype and example. Most of the time, the basic prototype will be suitable for your need. But JAR Template movement functions are overloaded, which means that you can provide extra information to the function on the fly, depending on the movement you want to make. And although only a "basic" and an "advanced" function are included here, most of the movement functions are overloaded even more, allowing for more flexibility.')),(0,o.yg)("admonition",{type:"info"},(0,o.yg)("p",{parentName:"admonition"},"On units in JAR Template: all functions take angles in degrees, distances in inches, times in milliseconds, and voltages in volts, with a maximum voltage of 12.")),(0,o.yg)("h2",{id:"non-odometry-functions"},"Non-Odometry Functions"),(0,o.yg)("h3",{id:"turn_to_angle"},"turn_to_angle();"),(0,o.yg)(l.A,{groupId:"turn",defaultValue:"proto1",values:[{label:"Basic Prototype",value:"proto1"},{label:"Basic Example",value:"example1"},{label:"Advanced Prototype",value:"proto2"},{label:"Advanced Example",value:"example2"}],mdxType:"Tabs"},(0,o.yg)(r.A,{value:"example1",mdxType:"TabItem"},(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-cpp"},"void left_side_auto{\n    chassis.drive_distance(10);\n    chassis.turn_to_angle(-90);\n    Intake.spin(reverse, 100, pct);\n    task::sleep(1000);\n    Intake.stop(coast);\n    chassis.turn_to_angle(0);\n    chassis.drive_distance(-10);\n}\n"))),(0,o.yg)(r.A,{value:"proto1",mdxType:"TabItem"},(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-cpp"},"void Drive::turn_to_angle(float angle);\n"))),(0,o.yg)(r.A,{value:"example2",mdxType:"TabItem"},(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-cpp"},"void left_side_auto{\n    chassis.drive_distance(10);\n    chassis.turn_to_angle(-90, 6, 0.5, 500, 4000, 3, 0, 3, 15);\n    Intake.spin(reverse, 100, pct);\n    task::sleep(1000);\n    Intake.stop(coast);\n    chassis.turn_to_angle(0);\n    chassis.drive_distance(-10);\n}\n"))),(0,o.yg)(r.A,{value:"proto2",mdxType:"TabItem"},(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-cpp"},"void Drive::turn_to_angle(float angle, float turn_max_voltage, float turn_settle_error, float turn_settle_time, float turn_timeout, float turn_kp, float turn_ki, float turn_kd, float turn_starti);\n")))),(0,o.yg)("admonition",{type:"note"},(0,o.yg)("p",{parentName:"admonition"},"In JAR Template, turns are ",(0,o.yg)("em",{parentName:"p"},"field-centric"),", meaning that using ",(0,o.yg)("inlineCode",{parentName:"p"},"chassis.turn_to_angle(0);")," will always bring the robot to the same orientation in which it began the autonomous function.")),(0,o.yg)("h3",{id:"drive_distance"},"drive_distance();"),(0,o.yg)(l.A,{groupId:"drive",defaultValue:"proto1",values:[{label:"Basic Prototype",value:"proto1"},{label:"Basic Example",value:"example1"},{label:"Advanced Prototype",value:"proto2"},{label:"Advanced Example",value:"example2"}],mdxType:"Tabs"},(0,o.yg)(r.A,{value:"example1",mdxType:"TabItem"},(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-cpp"},"void left_side_auto{\n    chassis.drive_distance(10);\n    chassis.turn_to_angle(-90);\n    Intake.spin(reverse, 100, pct);\n    task::sleep(1000);\n    Intake.stop(coast);\n    chassis.turn_to_angle(0);\n    chassis.drive_distance(-10);\n}\n"))),(0,o.yg)(r.A,{value:"proto1",mdxType:"TabItem"},(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-cpp"},"void Drive::drive_distance(float distance);\n"))),(0,o.yg)(r.A,{value:"example2",mdxType:"TabItem"},(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-cpp"},"void left_side_auto{\n    chassis.drive_distance(10, 5, 3, 3, 2, 500, 4000, 1, 0, 3, 0, 3, 0, 5, 0);\n    chassis.turn_to_angle(-90);\n    Intake.spin(reverse, 100, pct);\n    task::sleep(1000);\n    Intake.stop(coast);\n    chassis.turn_to_angle(0);\n    chassis.drive_distance(-10);\n}\n"))),(0,o.yg)(r.A,{value:"proto2",mdxType:"TabItem"},(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-cpp"},"void Drive::drive_distance(float distance, float heading, float drive_max_voltage, float heading_max_voltage, float drive_settle_error, float drive_settle_time, float drive_timeout, float drive_kp, float drive_ki, float drive_kd, float drive_starti, float heading_kp, float heading_ki, float heading_kd, float heading_starti);\n")))),(0,o.yg)("h3",{id:"left_swing_to_angle"},"left_swing_to_angle();"),(0,o.yg)(l.A,{groupId:"leftswing",defaultValue:"proto1",values:[{label:"Basic Prototype",value:"proto1"},{label:"Basic Example",value:"example1"},{label:"Advanced Prototype",value:"proto2"},{label:"Advanced Example",value:"example2"}],mdxType:"Tabs"},(0,o.yg)(r.A,{value:"example1",mdxType:"TabItem"},(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-cpp"},"void left_side_auto{\n    chassis.drive_distance(10);\n    chassis.left_swing_to_angle(90);\n    Intake.spin(reverse, 100, pct);\n    task::sleep(1000);\n    Intake.stop(coast);\n    chassis.left_swing_to_angle(0);\n    chassis.drive_distance(-10);\n}\n"))),(0,o.yg)(r.A,{value:"proto1",mdxType:"TabItem"},(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-cpp"},"void Drive::left_swing_to_angle(float angle);\n"))),(0,o.yg)(r.A,{value:"example2",mdxType:"TabItem"},(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-cpp"},"void left_side_auto{\n    chassis.drive_distance(10);\n    chassis.left_swing_to_angle(90, 8, 2, 0, 1000, 2, 0, 7, 0);\n    Intake.spin(reverse, 100, pct);\n    task::sleep(1000);\n    Intake.stop(coast);\n    chassis.left_swing_to_angle(0);\n    chassis.drive_distance(-10);\n}\n"))),(0,o.yg)(r.A,{value:"proto2",mdxType:"TabItem"},(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-cpp"},"void Drive::left_swing_to_angle(float angle, float swing_max_voltage, float swing_settle_error, float swing_settle_time, float swing_timeout, float swing_kp, float swing_ki, float swing_kd, float swing_starti);\n")))),(0,o.yg)("h3",{id:"right_swing_to_angle"},"right_swing_to_angle();"),(0,o.yg)(l.A,{groupId:"rightswing",defaultValue:"proto1",values:[{label:"Basic Prototype",value:"proto1"},{label:"Basic Example",value:"example1"},{label:"Advanced Prototype",value:"proto2"},{label:"Advanced Example",value:"example2"}],mdxType:"Tabs"},(0,o.yg)(r.A,{value:"example1",mdxType:"TabItem"},(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-cpp"},"void left_side_auto{\n    chassis.drive_distance(10);\n    chassis.right_swing_to_angle(90);\n    Intake.spin(reverse, 100, pct);\n    task::sleep(1000);\n    Intake.stop(coast);\n    chassis.right_swing_to_angle(0);\n    chassis.drive_distance(-10);\n    }\n"))),(0,o.yg)(r.A,{value:"proto1",mdxType:"TabItem"},(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-cpp"},"void Drive::right_swing_to_angle(float angle);\n"))),(0,o.yg)(r.A,{value:"example2",mdxType:"TabItem"},(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-cpp"},"void left_side_auto{\n    chassis.drive_distance(10);\n    chassis.right_swing_to_angle(90, 8, 2, 0, 1000, 2, 0, 7, 0);\n    Intake.spin(reverse, 100, pct);\n    task::sleep(1000);\n    Intake.stop(coast);\n    chassis.right_swing_to_angle(0);\n    chassis.drive_distance(-10);\n}\n"))),(0,o.yg)(r.A,{value:"proto2",mdxType:"TabItem"},(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-cpp"},"void Drive::right_swing_to_angle(float angle, float swing_max_voltage, float swing_settle_error, float swing_settle_time, float swing_timeout, float swing_kp, float swing_ki, float swing_kd, float swing_starti);\n")))),(0,o.yg)("h2",{id:"odometry-functions"},"Odometry Functions"),(0,o.yg)("h3",{id:"drive_to_point"},"drive_to_point();"),(0,o.yg)(l.A,{groupId:"drivepoint",defaultValue:"proto1",values:[{label:"Basic Prototype",value:"proto1"},{label:"Basic Example",value:"example1"},{label:"Advanced Prototype",value:"proto2"},{label:"Advanced Example",value:"example2"}],mdxType:"Tabs"},(0,o.yg)(r.A,{value:"example1",mdxType:"TabItem"},(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-cpp"},"void left_side_auto{\n    chassis.set_coordinates(0, 0, 0);\n    chassis.drive_to_point(6, 18);\n    chassis.turn_to_angle(-10);\n    Intake.spin(reverse, 100, percent);\n    task::sleep(1000);\n    Intake.stop(coast);\n    chassis.drive_to_point(0, 0);\n}\n"))),(0,o.yg)(r.A,{value:"proto1",mdxType:"TabItem"},(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-cpp"},"void Drive::drive_to_point(float X_position, float Y_position);\n\n"))),(0,o.yg)(r.A,{value:"example2",mdxType:"TabItem"},(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-cpp"},"void left_side_auto{\n    chassis.set_coordinates(0, 0, 0);\n    chassis.drive_to_point(6, 18, 5, 3, 4, 400, 5000, 1, 0, 3, 0, 2, 0, 7, 0);\n    chassis.turn_to_angle(-10);\n    Intake.spin(reverse, 100, percent);\n    task::sleep(1000);\n    Intake.stop(coast);\n    chassis.drive_to_point(0, 0);\n}\n"))),(0,o.yg)(r.A,{value:"proto2",mdxType:"TabItem"},(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-cpp"},"void Drive::drive_to_point(float X_position, float Y_position, float drive_max_voltage, float heading_max_voltage, float drive_settle_error, float drive_settle_time, float drive_timeout, float drive_kp, float drive_ki, float drive_kd, float drive_starti, float heading_kp, float heading_ki, float heading_kd, float heading_starti);\n")))),(0,o.yg)("h3",{id:"turn_to_point"},"turn_to_point();"),(0,o.yg)(l.A,{groupId:"turnpoint",defaultValue:"proto1",values:[{label:"Basic Prototype",value:"proto1"},{label:"Basic Example",value:"example1"},{label:"Advanced Prototype",value:"proto2"},{label:"Advanced Example",value:"example2"}],mdxType:"Tabs"},(0,o.yg)(r.A,{value:"example1",mdxType:"TabItem"},(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-cpp"},"void left_side_auto{\n    chassis.set_coordinates(0, 0, 0);\n    chassis.drive_to_point(6, 18);\n    chassis.turn_to_point(20, 30);\n    Intake.spin(reverse, 100, percent);\n    task::sleep(1000);\n    Intake.stop(coast);\n    chassis.drive_to_point(0, 0);\n}\n"))),(0,o.yg)(r.A,{value:"proto1",mdxType:"TabItem"},(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-cpp"},"void Drive::turn_to_point(float X_position, float Y_position);\n\n"))),(0,o.yg)(r.A,{value:"example2",mdxType:"TabItem"},(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-cpp"},"void left_side_auto{\n    chassis.set_coordinates(0, 0, 0);\n    chassis.drive_to_point(6, 18);\n    chassis.turn_to_point(20, 30, 5, 12, 1, 200, 3000, 1, 0, 3, 0);\n    Intake.spin(reverse, 100, percent);\n    task::sleep(1000);\n    Intake.stop(coast);\n    chassis.drive_to_point(0, 0);\n}\n"))),(0,o.yg)(r.A,{value:"proto2",mdxType:"TabItem"},(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-cpp"},"void Drive::turn_to_point(float X_position, float Y_position, float extra_angle_deg, float turn_max_voltage, float turn_settle_error, float turn_settle_time, float turn_timeout, float turn_kp, float turn_ki, float turn_kd, float turn_starti);\n")))),(0,o.yg)("admonition",{type:"note"},(0,o.yg)("p",{parentName:"admonition"},(0,o.yg)("inlineCode",{parentName:"p"},"float extra_angle_deg")," is used to specify some deviation from the front of the robot and the desired point. Specifically, the controller will make the robot overshoot by that amount of degrees. So an ",(0,o.yg)("inlineCode",{parentName:"p"},"extra_angle_deg")," value of 90 will make the robot turn its left side toward the desired point.")),(0,o.yg)("h3",{id:"holonomic_drive_to_point"},"holonomic_drive_to_point();"),(0,o.yg)(l.A,{groupId:"holodrive",defaultValue:"proto1",values:[{label:"Basic Prototype",value:"proto1"},{label:"Basic Example",value:"example1"},{label:"Advanced Prototype",value:"proto2"},{label:"Advanced Example",value:"example2"}],mdxType:"Tabs"},(0,o.yg)(r.A,{value:"example1",mdxType:"TabItem"},(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-cpp"},"void left_side_auto{\n    chassis.set_coordinates(0, 0, 0);\n    chassis.holonomic_drive_to_point(6, 18);\n    chassis.turn_to_point(20, 30);\n    Intake.spin(reverse, 100, percent);\n    task::sleep(1000);\n    Intake.stop(coast);\n    chassis.holonomic_drive_to_point(0, 0);\n}\n"))),(0,o.yg)(r.A,{value:"proto1",mdxType:"TabItem"},(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-cpp"},"void Drive::holonomic_drive_to_point(float X_position, float Y_position);\n\n"))),(0,o.yg)(r.A,{value:"example2",mdxType:"TabItem"},(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-cpp"},"void left_side_auto{\n    chassis.set_coordinates(0, 0, 0);\n    chassis.holonomic_drive_to_point(6, 18, 20, 6, 6, 2, 200, 3000, 1, 0, 3, 0, 2, 0, 7, 0);\n    Intake.spin(reverse, 100, percent);\n    task::sleep(1000);\n    Intake.stop(coast);\n    chassis.holonomic_drive_to_point(0, 0);\n}\n"))),(0,o.yg)(r.A,{value:"proto2",mdxType:"TabItem"},(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-cpp"},"void Drive::holonomic_drive_to_point(float X_position, float Y_position, float angle, float drive_max_voltage, float heading_max_voltage, float drive_settle_error, float drive_settle_time, float drive_timeout, float drive_kp, float drive_ki, float drive_kd, float drive_starti, float heading_kp, float heading_ki, float heading_kd, float heading_starti);\n")))),(0,o.yg)("admonition",{type:"note"},(0,o.yg)("p",{parentName:"admonition"},"When the value of ",(0,o.yg)("inlineCode",{parentName:"p"},"angle")," is specified, the controller will attempt to drive the robot to the desired point and turn it to the desired angle simultaneously. When it is left unspecified, the robot will maintain its orientation throughout the movement.")))}m.isMDXComponent=!0}}]);