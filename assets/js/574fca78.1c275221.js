"use strict";(self.webpackChunksite=self.webpackChunksite||[]).push([[864],{5680:(e,t,r)=>{r.d(t,{xA:()=>u,yg:()=>m});var o=r(6540);function n(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,o)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){n(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,o,n=function(e,t){if(null==e)return{};var r,o,n={},a=Object.keys(e);for(o=0;o<a.length;o++)r=a[o],t.indexOf(r)>=0||(n[r]=e[r]);return n}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)r=a[o],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}var l=o.createContext({}),c=function(e){var t=o.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},u=function(e){var t=c(e.components);return o.createElement(l.Provider,{value:t},e.children)},h="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},p=o.forwardRef((function(e,t){var r=e.components,n=e.mdxType,a=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),h=c(r),p=n,m=h["".concat(l,".").concat(p)]||h[p]||d[p]||a;return r?o.createElement(m,i(i({ref:t},u),{},{components:r})):o.createElement(m,i({ref:t},u))}));function m(e,t){var r=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var a=r.length,i=new Array(a);i[0]=p;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[h]="string"==typeof e?e:n,i[1]=s;for(var c=2;c<a;c++)i[c]=r[c];return o.createElement.apply(null,i)}return o.createElement.apply(null,r)}p.displayName="MDXCreateElement"},9365:(e,t,r)=>{r.d(t,{A:()=>i});var o=r(6540),n=r(53);const a={tabItem:"tabItem_Ymn6"};function i(e){let{children:t,hidden:r,className:i}=e;return o.createElement("div",{role:"tabpanel",className:(0,n.A)(a.tabItem,i),hidden:r},t)}},1470:(e,t,r)=>{r.d(t,{A:()=>v});var o=r(8168),n=r(6540),a=r(53),i=r(3104),s=r(6347),l=r(7485),c=r(1682),u=r(9466);function h(e){return function(e){return n.Children.map(e,(e=>{if(!e||(0,n.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}(e).map((e=>{let{props:{value:t,label:r,attributes:o,default:n}}=e;return{value:t,label:r,attributes:o,default:n}}))}function d(e){const{values:t,children:r}=e;return(0,n.useMemo)((()=>{const e=t??h(r);return function(e){const t=(0,c.X)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,r])}function p(e){let{value:t,tabValues:r}=e;return r.some((e=>e.value===t))}function m(e){let{queryString:t=!1,groupId:r}=e;const o=(0,s.W6)(),a=function(e){let{queryString:t=!1,groupId:r}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!r)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return r??null}({queryString:t,groupId:r});return[(0,l.aZ)(a),(0,n.useCallback)((e=>{if(!a)return;const t=new URLSearchParams(o.location.search);t.set(a,e),o.replace({...o.location,search:t.toString()})}),[a,o])]}function y(e){const{defaultValue:t,queryString:r=!1,groupId:o}=e,a=d(e),[i,s]=(0,n.useState)((()=>function(e){let{defaultValue:t,tabValues:r}=e;if(0===r.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!p({value:t,tabValues:r}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${r.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const o=r.find((e=>e.default))??r[0];if(!o)throw new Error("Unexpected error: 0 tabValues");return o.value}({defaultValue:t,tabValues:a}))),[l,c]=m({queryString:r,groupId:o}),[h,y]=function(e){let{groupId:t}=e;const r=function(e){return e?`docusaurus.tab.${e}`:null}(t),[o,a]=(0,u.Dv)(r);return[o,(0,n.useCallback)((e=>{r&&a.set(e)}),[r,a])]}({groupId:o}),T=(()=>{const e=l??h;return p({value:e,tabValues:a})?e:null})();(0,n.useLayoutEffect)((()=>{T&&s(T)}),[T]);return{selectedValue:i,selectValue:(0,n.useCallback)((e=>{if(!p({value:e,tabValues:a}))throw new Error(`Can't select invalid tab value=${e}`);s(e),c(e),y(e)}),[c,y,a]),tabValues:a}}var T=r(2303);const O={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function g(e){let{className:t,block:r,selectedValue:s,selectValue:l,tabValues:c}=e;const u=[],{blockElementScrollPositionUntilNextRender:h}=(0,i.a_)(),d=e=>{const t=e.currentTarget,r=u.indexOf(t),o=c[r].value;o!==s&&(h(t),l(o))},p=e=>{let t=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const r=u.indexOf(e.currentTarget)+1;t=u[r]??u[0];break}case"ArrowLeft":{const r=u.indexOf(e.currentTarget)-1;t=u[r]??u[u.length-1];break}}t?.focus()};return n.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,a.A)("tabs",{"tabs--block":r},t)},c.map((e=>{let{value:t,label:r,attributes:i}=e;return n.createElement("li",(0,o.A)({role:"tab",tabIndex:s===t?0:-1,"aria-selected":s===t,key:t,ref:e=>u.push(e),onKeyDown:p,onClick:d},i,{className:(0,a.A)("tabs__item",O.tabItem,i?.className,{"tabs__item--active":s===t})}),r??t)})))}function _(e){let{lazy:t,children:r,selectedValue:o}=e;const a=(Array.isArray(r)?r:[r]).filter(Boolean);if(t){const e=a.find((e=>e.props.value===o));return e?(0,n.cloneElement)(e,{className:"margin-top--md"}):null}return n.createElement("div",{className:"margin-top--md"},a.map(((e,t)=>(0,n.cloneElement)(e,{key:t,hidden:e.props.value!==o}))))}function f(e){const t=y(e);return n.createElement("div",{className:(0,a.A)("tabs-container",O.tabList)},n.createElement(g,(0,o.A)({},e,t)),n.createElement(_,(0,o.A)({},e,t)))}function v(e){const t=(0,T.A)();return n.createElement(f,(0,o.A)({key:String(t)},e))}},9411:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>u,contentTitle:()=>l,default:()=>m,frontMatter:()=>s,metadata:()=>c,toc:()=>h});var o=r(8168),n=(r(6540),r(5680)),a=r(1470),i=r(9365);const s={sidebar_position:1,sidebar_label:"Drive Constructor"},l="Drive Constructor",c={unversionedId:"docs/drive-class/drive-constructor",id:"docs/drive-class/drive-constructor",title:"Drive Constructor",description:"The JAR Template drive constructor can build drivetrains with no tracking wheels, but also supports tank and holonomic odometry, with either red optical encoders or V5 rotation sensors. Note that each constructor has the same prototype, and that every drive style requires a V5 inertial sensor.",source:"@site/docs/docs/drive-class/drive-constructor.md",sourceDirName:"docs/drive-class",slug:"/docs/drive-class/drive-constructor",permalink:"/JAR-Template/docs/drive-class/drive-constructor",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,sidebar_label:"Drive Constructor"},sidebar:"tutorialSidebar",previous:{title:"Drive Class",permalink:"/JAR-Template/docs/drive-class/"},next:{title:"Motion Functions",permalink:"/JAR-Template/docs/drive-class/motion-functions"}},u={},h=[{value:"Drive Setup Examples",id:"drive-setup-examples",level:2},{value:"ZERO_TRACKER_NO_ODOM",id:"zero_tracker_no_odom",level:3},{value:"ZERO_TRACKER_ODOM",id:"zero_tracker_odom",level:3},{value:"TANK_ONE_FORWARD_ENCODER",id:"tank_one_forward_encoder",level:3},{value:"TANK_ONE_FORWARD_ROTATION",id:"tank_one_forward_rotation",level:3},{value:"TANK_ONE_SIDEWAYS_ENCODER",id:"tank_one_sideways_encoder",level:3},{value:"TANK_ONE_SIDEWAYS_ROTATION",id:"tank_one_sideways_rotation",level:3},{value:"TANK_TWO_ENCODER",id:"tank_two_encoder",level:3},{value:"TANK_TWO_ROTATION",id:"tank_two_rotation",level:3},{value:"HOLONOMIC_TWO_ENCODER",id:"holonomic_two_encoder",level:3},{value:"HOLONOMIC_TWO_ROTATION",id:"holonomic_two_rotation",level:3},{value:"On Gyro Scale",id:"on-gyro-scale",level:2},{value:"Intuition",id:"intuition",level:3},{value:"Usage",id:"usage",level:3}],d={toc:h},p="wrapper";function m(e){let{components:t,...r}=e;return(0,n.yg)(p,(0,o.A)({},d,r,{components:t,mdxType:"MDXLayout"}),(0,n.yg)("h1",{id:"drive-constructor"},"Drive Constructor"),(0,n.yg)("p",null,"The JAR Template drive constructor can build drivetrains with no tracking wheels, but also supports tank and holonomic odometry, with either red optical encoders or V5 rotation sensors. Note that each constructor has the same prototype, and that every drive style ",(0,n.yg)("strong",{parentName:"p"},"requires")," a V5 inertial sensor."),(0,n.yg)("admonition",{type:"caution"},(0,n.yg)("p",{parentName:"admonition"},(0,n.yg)("strong",{parentName:"p"},"Do not try to add extra motor groups, sensors, or values to the constructor or to remove any that you do not need. The code will not compile. Follow the style of the examples, only filling in fields that are already present."))),(0,n.yg)("admonition",{type:"note"},(0,n.yg)("p",{parentName:"admonition"},'For odometry users using red optical encoders: the top wire of the encoder is always plugged in one port above the bottom wire, and it is the top wire that is indicated in VexCode. So putting the port as "3" means that the encoder is plugged into triports C and D on the brain with the top wire in port C and the bottom wire in port D. Likewise, putting the port as "5" means the encoder is plugged into ports E and F.')),(0,n.yg)("h2",{id:"drive-setup-examples"},"Drive Setup Examples"),(0,n.yg)("p",null,"Drive constructor for the chassis. Even though there's only one constructor, there can be huge differences in implementation depending on the drive style selected."),(0,n.yg)("table",null,(0,n.yg)("thead",{parentName:"table"},(0,n.yg)("tr",{parentName:"thead"},(0,n.yg)("th",{parentName:"tr",align:null},"Parameters"),(0,n.yg)("th",{parentName:"tr",align:null}))),(0,n.yg)("tbody",{parentName:"table"},(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"drive_setup"),(0,n.yg)("td",{parentName:"tr",align:null},"The style of drive, such as TANK_TWO_ROTATION.")),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"DriveL"),(0,n.yg)("td",{parentName:"tr",align:null},"Left motor group.")),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"DriveR"),(0,n.yg)("td",{parentName:"tr",align:null},"Right motor group.")),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"gyro_port"),(0,n.yg)("td",{parentName:"tr",align:null},"IMU port.")),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"wheel_diameter"),(0,n.yg)("td",{parentName:"tr",align:null},"Wheel diameter in inches.")),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"wheel_ratio"),(0,n.yg)("td",{parentName:"tr",align:null},"External drive gear ratio.")),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"gyro_scale"),(0,n.yg)("td",{parentName:"tr",align:null},"Scale factor in degrees.")),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"DriveLF_port"),(0,n.yg)("td",{parentName:"tr",align:null},"Left front port for holonomic drives.")),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"DriveRF_port"),(0,n.yg)("td",{parentName:"tr",align:null},"Right front port for holonomic drives.")),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"DriveLB_port"),(0,n.yg)("td",{parentName:"tr",align:null},"Left back port for holonomic drives.")),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"DriveRB_port"),(0,n.yg)("td",{parentName:"tr",align:null},"Right back port for holonomic drives.")),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"ForwardTracker_port"),(0,n.yg)("td",{parentName:"tr",align:null},"Port for the forward tracker.")),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"ForwardTracker_diameter"),(0,n.yg)("td",{parentName:"tr",align:null},"Diameter in inches.")),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"ForwardTracker_center_distance"),(0,n.yg)("td",{parentName:"tr",align:null},"Horizontal distance in inches.")),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"SidewaysTracker_port"),(0,n.yg)("td",{parentName:"tr",align:null},"Port for the sideways tracker.")),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"SidewaysTracker_diameter"),(0,n.yg)("td",{parentName:"tr",align:null},"Diameter in inches.")),(0,n.yg)("tr",{parentName:"tbody"},(0,n.yg)("td",{parentName:"tr",align:null},"SidewaysTracker_center_distance"),(0,n.yg)("td",{parentName:"tr",align:null},"Vertical distance in inches.")))),(0,n.yg)("h3",{id:"zero_tracker_no_odom"},"ZERO_TRACKER_NO_ODOM"),(0,n.yg)("p",null,"Note that for this drive setup, nothing needs to be edited after the gyro scale factor."),(0,n.yg)(a.A,{groupId:"zero_tracker",defaultValue:"proto",values:[{label:"Prototype",value:"proto"},{label:"Example",value:"example"}],mdxType:"Tabs"},(0,n.yg)(i.A,{value:"example",mdxType:"TabItem"},(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-cpp"},'Drive chassis(\n\n//Pick your drive setup from the list below:\n//ZERO_TRACKER_NO_ODOM\n//ZERO_TRACKER_ODOM\n//TANK_ONE_FORWARD_ENCODER\n//TANK_ONE_FORWARD_ROTATION\n//TANK_ONE_SIDEWAYS_ENCODER\n//TANK_ONE_SIDEWAYS_ROTATION\n//TANK_TWO_ENCODER\n//TANK_TWO_ROTATION\n//HOLONOMIC_TWO_ENCODER\n//HOLONOMIC_TWO_ROTATION\n//\n//Write it here:\nZERO_TRACKER_NO_ODOM,\n\n//Add the names of your Drive motors into the motor groups below, separated by commas, i.e. motor_group(Motor1,Motor2,Motor3).\n//You will input whatever motor names you chose when you configured your robot using the sidebar configurer, they don\'t have to be "Motor1" and "Motor2".\n\n//Left Motors:\nmotor_group(LeftFront, LeftBack),\n\n//Right Motors:\nmotor_group(RightFront, RightBack),\n\n//Specify the PORT NUMBER of your inertial sensor, in PORT format (i.e. "PORT1", not simply "1"):\nPORT4,\n\n//Input your wheel diameter. (4" omnis are actually closer to 4.125"):\n4.125,\n\n//External ratio, must be in decimal, in the format of input teeth/output teeth.\n//If your motor has an 84-tooth gear and your wheel has a 60-tooth gear, this value will be 1.4.\n//If the motor drives the wheel directly, this value is 1:\n1.0,\n\n//Gyro scale, this is what your gyro reads when you spin the robot 360 degrees.\n//For most cases 360 will do fine here, but this scale factor can be very helpful when precision is necessary.\n360,\n\n/*---------------------------------------------------------------------------*/\n/*                                  PAUSE!                                   */\n/*                                                                           */\n/*  The rest of the drive constructor is for robots using POSITION TRACKING. */\n/*  If you are not using position tracking, leave the rest of the values as  */\n/*  they are.                                                                */\n/*---------------------------------------------------------------------------*/\n\n//If you are using ZERO_TRACKER_ODOM, you ONLY need to adjust the FORWARD TRACKER CENTER DISTANCE.\n\n//FOR HOLONOMIC DRIVES ONLY: Input your drive motors by position. This is only necessary for holonomic drives, otherwise this section can be left alone.\n//LF:      //RF:    \nPORT1,     -PORT2,\n\n//LB:      //RB: \nPORT3,     -PORT4,\n\n//If you are using position tracking, this is the Forward Tracker port (the tracker which runs parallel to the direction of the chassis).\n//If this is a rotation sensor, enter it in "PORT1" format, inputting the port below.\n//If this is an encoder, enter the port as an integer. Triport A will be a "1", Triport B will be a "2", etc.\n3,\n\n//Input the Forward Tracker diameter (reverse it to make the direction switch):\n2.75,\n\n//Input Forward Tracker center distance (a positive distance corresponds to a tracker on the right side of the robot, negative is left.)\n//For a zero tracker tank drive with odom, put the positive distance from the center of the robot to the right side of the drive.\n//This distance is in inches:\n-2,\n\n//Input the Sideways Tracker Port, following the same steps as the Forward Tracker Port:\n1,\n\n//Sideways tracker diameter (reverse to make the direction switch):\n-2.75,\n\n//Sideways tracker center distance (positive distance is behind the center of the robot, negative is in front):\n5.5\n\n);\n'))),(0,n.yg)(i.A,{value:"proto",mdxType:"TabItem"},(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-cpp"},"Drive::Drive(enum::drive_setup drive_setup, motor_group DriveL, motor_group DriveR, int gyro_port, float wheel_diameter, float wheel_ratio, float gyro_scale, int DriveLF_port, int DriveRF_port, int DriveLB_port, int DriveRB_port, int ForwardTracker_port, float ForwardTracker_diameter, float ForwardTracker_center_distance, int SidewaysTracker_port, float SidewaysTracker_diameter, float SidewaysTracker_center_distance);\n")))),(0,n.yg)("h3",{id:"zero_tracker_odom"},"ZERO_TRACKER_ODOM"),(0,n.yg)("p",null,"For this drive setup, the only thing that needs to be edited after gyro scale factor is the Forward Tracker Center distance. Since this constructor uses the right side drive motor encoders to track position, Forward Tracker Center distance is just the distance from the center of your robot to the right set of wheels."),(0,n.yg)(a.A,{groupId:"zero_tracker_odom",defaultValue:"proto",values:[{label:"Prototype",value:"proto"},{label:"Example",value:"example"}],mdxType:"Tabs"},(0,n.yg)(i.A,{value:"example",mdxType:"TabItem"},(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-cpp"},'Drive chassis(\n\n//Pick your drive setup from the list below:\n//ZERO_TRACKER_NO_ODOM\n//ZERO_TRACKER_ODOM\n//TANK_ONE_FORWARD_ENCODER\n//TANK_ONE_FORWARD_ROTATION\n//TANK_ONE_SIDEWAYS_ENCODER\n//TANK_ONE_SIDEWAYS_ROTATION\n//TANK_TWO_ENCODER\n//TANK_TWO_ROTATION\n//HOLONOMIC_TWO_ENCODER\n//HOLONOMIC_TWO_ROTATION\n//\n//Write it here:\nZERO_TRACKER_ODOM,\n\n//Add the names of your Drive motors into the motor groups below, separated by commas, i.e. motor_group(Motor1,Motor2,Motor3).\n//You will input whatever motor names you chose when you configured your robot using the sidebar configurer, they don\'t have to be "Motor1" and "Motor2".\n\n//Left Motors:\nmotor_group(LeftFront, LeftBack),\n\n//Right Motors:\nmotor_group(RightFront, RightBack),\n\n//Specify the PORT NUMBER of your inertial sensor, in PORT format (i.e. "PORT1", not simply "1"):\nPORT4,\n\n//Input your wheel diameter. (4" omnis are actually closer to 4.125"):\n4.125,\n\n//External ratio, must be in decimal, in the format of input teeth/output teeth.\n//If your motor has an 84-tooth gear and your wheel has a 60-tooth gear, this value will be 1.4.\n//If the motor drives the wheel directly, this value is 1:\n1.0,\n\n//Gyro scale, this is what your gyro reads when you spin the robot 360 degrees.\n//For most cases 360 will do fine here, but this scale factor can be very helpful when precision is necessary.\n360,\n\n/*---------------------------------------------------------------------------*/\n/*                                  PAUSE!                                   */\n/*                                                                           */\n/*  The rest of the drive constructor is for robots using POSITION TRACKING. */\n/*  If you are not using position tracking, leave the rest of the values as  */\n/*  they are.                                                                */\n/*---------------------------------------------------------------------------*/\n\n//If you are using ZERO_TRACKER_ODOM, you ONLY need to adjust the FORWARD TRACKER CENTER DISTANCE.\n\n//FOR HOLONOMIC DRIVES ONLY: Input your drive motors by position. This is only necessary for holonomic drives, otherwise this section can be left alone.\n//LF:      //RF:    \nPORT1,     -PORT2,\n\n//LB:      //RB: \nPORT3,     -PORT4,\n\n//If you are using position tracking, this is the Forward Tracker port (the tracker which runs parallel to the direction of the chassis).\n//If this is a rotation sensor, enter it in "PORT1" format, inputting the port below.\n//If this is an encoder, enter the port as an integer. Triport A will be a "1", Triport B will be a "2", etc.\n3,\n\n//Input the Forward Tracker diameter (reverse it to make the direction switch):\n2.75,\n\n//Input Forward Tracker center distance (a positive distance corresponds to a tracker on the right side of the robot, negative is left.)\n//For a zero tracker tank drive with odom, put the positive distance from the center of the robot to the right side of the drive.\n//This distance is in inches:\n5.25,\n\n//Input the Sideways Tracker Port, following the same steps as the Forward Tracker Port:\n1,\n\n//Sideways tracker diameter (reverse to make the direction switch):\n-2.75,\n\n//Sideways tracker center distance (positive distance is behind the center of the robot, negative is in front):\n5.5\n\n);\n'))),(0,n.yg)(i.A,{value:"proto",mdxType:"TabItem"},(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-cpp"},"Drive::Drive(enum::drive_setup drive_setup, motor_group DriveL, motor_group DriveR, int gyro_port, float wheel_diameter, float wheel_ratio, float gyro_scale, int DriveLF_port, int DriveRF_port, int DriveLB_port, int DriveRB_port, int ForwardTracker_port, float ForwardTracker_diameter, float ForwardTracker_center_distance, int SidewaysTracker_port, float SidewaysTracker_diameter, float SidewaysTracker_center_distance);\n")))),(0,n.yg)("h3",{id:"tank_one_forward_encoder"},"TANK_ONE_FORWARD_ENCODER"),(0,n.yg)("p",null,"This style of odometry has a single tracker measuring forward/backward movement. This typically makes sense if the robot has traction wheels, because it can't measure sideways movement. See the note above about optical encoder wiring."),(0,n.yg)(a.A,{groupId:"tank_one_forward_encoder",defaultValue:"proto",values:[{label:"Prototype",value:"proto"},{label:"Example",value:"example"}],mdxType:"Tabs"},(0,n.yg)(i.A,{value:"example",mdxType:"TabItem"},(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-cpp"},'Drive chassis(\n\n//Pick your drive setup from the list below:\n//ZERO_TRACKER_NO_ODOM\n//ZERO_TRACKER_ODOM\n//TANK_ONE_FORWARD_ENCODER\n//TANK_ONE_FORWARD_ROTATION\n//TANK_ONE_SIDEWAYS_ENCODER\n//TANK_ONE_SIDEWAYS_ROTATION\n//TANK_TWO_ENCODER\n//TANK_TWO_ROTATION\n//HOLONOMIC_TWO_ENCODER\n//HOLONOMIC_TWO_ROTATION\n//\n//Write it here:\nTANK_ONE_FORWARD_ENCODER,\n\n//Add the names of your Drive motors into the motor groups below, separated by commas, i.e. motor_group(Motor1,Motor2,Motor3).\n//You will input whatever motor names you chose when you configured your robot using the sidebar configurer, they don\'t have to be "Motor1" and "Motor2".\n\n//Left Motors:\nmotor_group(LeftFront, LeftBack),\n\n//Right Motors:\nmotor_group(RightFront, RightBack),\n\n//Specify the PORT NUMBER of your inertial sensor, in PORT format (i.e. "PORT1", not simply "1"):\nPORT4,\n\n//Input your wheel diameter. (4" omnis are actually closer to 4.125"):\n4.125,\n\n//External ratio, must be in decimal, in the format of input teeth/output teeth.\n//If your motor has an 84-tooth gear and your wheel has a 60-tooth gear, this value will be 1.4.\n//If the motor drives the wheel directly, this value is 1:\n1.0,\n\n//Gyro scale, this is what your gyro reads when you spin the robot 360 degrees.\n//For most cases 360 will do fine here, but this scale factor can be very helpful when precision is necessary.\n360,\n\n/*---------------------------------------------------------------------------*/\n/*                                  PAUSE!                                   */\n/*                                                                           */\n/*  The rest of the drive constructor is for robots using POSITION TRACKING. */\n/*  If you are not using position tracking, leave the rest of the values as  */\n/*  they are.                                                                */\n/*---------------------------------------------------------------------------*/\n\n//If you are using ZERO_TRACKER_ODOM, you ONLY need to adjust the FORWARD TRACKER CENTER DISTANCE.\n\n//FOR HOLONOMIC DRIVES ONLY: Input your drive motors by position. This is only necessary for holonomic drives, otherwise this section can be left alone.\n//LF:      //RF:    \nPORT1,     -PORT2,\n\n//LB:      //RB: \nPORT3,     -PORT4,\n\n//If you are using position tracking, this is the Forward Tracker port (the tracker which runs parallel to the direction of the chassis).\n//If this is a rotation sensor, enter it in "PORT1" format, inputting the port below.\n//If this is an encoder, enter the port as an integer. Triport A will be a "1", Triport B will be a "2", etc.\n5,\n\n//Input the Forward Tracker diameter (reverse it to make the direction switch):\n2.75,\n\n//Input Forward Tracker center distance (a positive distance corresponds to a tracker on the right side of the robot, negative is left.)\n//For a zero tracker tank drive with odom, put the positive distance from the center of the robot to the right side of the drive.\n//This distance is in inches:\n5.25,\n\n//Input the Sideways Tracker Port, following the same steps as the Forward Tracker Port:\n1,\n\n//Sideways tracker diameter (reverse to make the direction switch):\n-2.75,\n\n//Sideways tracker center distance (positive distance is behind the center of the robot, negative is in front):\n5.5\n\n);\n'))),(0,n.yg)(i.A,{value:"proto",mdxType:"TabItem"},(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-cpp"},"Drive::Drive(enum::drive_setup drive_setup, motor_group DriveL, motor_group DriveR, int gyro_port, float wheel_diameter, float wheel_ratio, float gyro_scale, int DriveLF_port, int DriveRF_port, int DriveLB_port, int DriveRB_port, int ForwardTracker_port, float ForwardTracker_diameter, float ForwardTracker_center_distance, int SidewaysTracker_port, float SidewaysTracker_diameter, float SidewaysTracker_center_distance);\n")))),(0,n.yg)("h3",{id:"tank_one_forward_rotation"},"TANK_ONE_FORWARD_ROTATION"),(0,n.yg)("p",null,"This style of odometry uses a V5 rotation sensor to measure forward/backward movement and assumes sideways slippage is minimal. This makes most sense on a drive with traction wheels."),(0,n.yg)(a.A,{groupId:"tank_one_forward_rotation",defaultValue:"proto",values:[{label:"Prototype",value:"proto"},{label:"Example",value:"example"}],mdxType:"Tabs"},(0,n.yg)(i.A,{value:"example",mdxType:"TabItem"},(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-cpp"},'Drive chassis(\n\n//Pick your drive setup from the list below:\n//ZERO_TRACKER_NO_ODOM\n//ZERO_TRACKER_ODOM\n//TANK_ONE_FORWARD_ENCODER\n//TANK_ONE_FORWARD_ROTATION\n//TANK_ONE_SIDEWAYS_ENCODER\n//TANK_ONE_SIDEWAYS_ROTATION\n//TANK_TWO_ENCODER\n//TANK_TWO_ROTATION\n//HOLONOMIC_TWO_ENCODER\n//HOLONOMIC_TWO_ROTATION\n//\n//Write it here:\nTANK_ONE_FORWARD_ROTATION,\n\n//Add the names of your Drive motors into the motor groups below, separated by commas, i.e. motor_group(Motor1,Motor2,Motor3).\n//You will input whatever motor names you chose when you configured your robot using the sidebar configurer, they don\'t have to be "Motor1" and "Motor2".\n\n//Left Motors:\nmotor_group(LeftFront, LeftBack),\n\n//Right Motors:\nmotor_group(RightFront, RightBack),\n\n//Specify the PORT NUMBER of your inertial sensor, in PORT format (i.e. "PORT1", not simply "1"):\nPORT4,\n\n//Input your wheel diameter. (4" omnis are actually closer to 4.125"):\n4.125,\n\n//External ratio, must be in decimal, in the format of input teeth/output teeth.\n//If your motor has an 84-tooth gear and your wheel has a 60-tooth gear, this value will be 1.4.\n//If the motor drives the wheel directly, this value is 1:\n1.0,\n\n//Gyro scale, this is what your gyro reads when you spin the robot 360 degrees.\n//For most cases 360 will do fine here, but this scale factor can be very helpful when precision is necessary.\n360,\n\n/*---------------------------------------------------------------------------*/\n/*                                  PAUSE!                                   */\n/*                                                                           */\n/*  The rest of the drive constructor is for robots using POSITION TRACKING. */\n/*  If you are not using position tracking, leave the rest of the values as  */\n/*  they are.                                                                */\n/*---------------------------------------------------------------------------*/\n\n//If you are using ZERO_TRACKER_ODOM, you ONLY need to adjust the FORWARD TRACKER CENTER DISTANCE.\n\n//FOR HOLONOMIC DRIVES ONLY: Input your drive motors by position. This is only necessary for holonomic drives, otherwise this section can be left alone.\n//LF:      //RF:    \nPORT1,     -PORT2,\n\n//LB:      //RB: \nPORT3,     -PORT4,\n\n//If you are using position tracking, this is the Forward Tracker port (the tracker which runs parallel to the direction of the chassis).\n//If this is a rotation sensor, enter it in "PORT1" format, inputting the port below.\n//If this is an encoder, enter the port as an integer. Triport A will be a "1", Triport B will be a "2", etc.\nPORT17,\n\n//Input the Forward Tracker diameter (reverse it to make the direction switch):\n2.75,\n\n//Input Forward Tracker center distance (a positive distance corresponds to a tracker on the right side of the robot, negative is left.)\n//For a zero tracker tank drive with odom, put the positive distance from the center of the robot to the right side of the drive.\n//This distance is in inches:\n5.25,\n\n//Input the Sideways Tracker Port, following the same steps as the Forward Tracker Port:\n1,\n\n//Sideways tracker diameter (reverse to make the direction switch):\n-2.75,\n\n//Sideways tracker center distance (positive distance is behind the center of the robot, negative is in front):\n2.5\n\n);\n'))),(0,n.yg)(i.A,{value:"proto",mdxType:"TabItem"},(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-cpp"},"Drive::Drive(enum::drive_setup drive_setup, motor_group DriveL, motor_group DriveR, int gyro_port, float wheel_diameter, float wheel_ratio, float gyro_scale, int DriveLF_port, int DriveRF_port, int DriveLB_port, int DriveRB_port, int ForwardTracker_port, float ForwardTracker_diameter, float ForwardTracker_center_distance, int SidewaysTracker_port, float SidewaysTracker_diameter, float SidewaysTracker_center_distance);\n")))),(0,n.yg)("h3",{id:"tank_one_sideways_encoder"},"TANK_ONE_SIDEWAYS_ENCODER"),(0,n.yg)("p",null,"This style of odometry uses the right side motor encoders to measure forward/backward movement and an optical encoder to measure sideways movement."),(0,n.yg)(a.A,{groupId:"tank_one_sideways_encoder",defaultValue:"proto",values:[{label:"Prototype",value:"proto"},{label:"Example",value:"example"}],mdxType:"Tabs"},(0,n.yg)(i.A,{value:"example",mdxType:"TabItem"},(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-cpp"},'Drive chassis(\n\n//Pick your drive setup from the list below:\n//ZERO_TRACKER_NO_ODOM\n//ZERO_TRACKER_ODOM\n//TANK_ONE_FORWARD_ENCODER\n//TANK_ONE_FORWARD_ROTATION\n//TANK_ONE_SIDEWAYS_ENCODER\n//TANK_ONE_SIDEWAYS_ROTATION\n//TANK_TWO_ENCODER\n//TANK_TWO_ROTATION\n//HOLONOMIC_TWO_ENCODER\n//HOLONOMIC_TWO_ROTATION\n//\n//Write it here:\nTANK_ONE_SIDEWAYS_ENCODER,\n\n//Add the names of your Drive motors into the motor groups below, separated by commas, i.e. motor_group(Motor1,Motor2,Motor3).\n//You will input whatever motor names you chose when you configured your robot using the sidebar configurer, they don\'t have to be "Motor1" and "Motor2".\n\n//Left Motors:\nmotor_group(LeftFront, LeftBack),\n\n//Right Motors:\nmotor_group(RightFront, RightBack),\n\n//Specify the PORT NUMBER of your inertial sensor, in PORT format (i.e. "PORT1", not simply "1"):\nPORT4,\n\n//Input your wheel diameter. (4" omnis are actually closer to 4.125"):\n4.125,\n\n//External ratio, must be in decimal, in the format of input teeth/output teeth.\n//If your motor has an 84-tooth gear and your wheel has a 60-tooth gear, this value will be 1.4.\n//If the motor drives the wheel directly, this value is 1:\n1.0,\n\n//Gyro scale, this is what your gyro reads when you spin the robot 360 degrees.\n//For most cases 360 will do fine here, but this scale factor can be very helpful when precision is necessary.\n360,\n\n/*---------------------------------------------------------------------------*/\n/*                                  PAUSE!                                   */\n/*                                                                           */\n/*  The rest of the drive constructor is for robots using POSITION TRACKING. */\n/*  If you are not using position tracking, leave the rest of the values as  */\n/*  they are.                                                                */\n/*---------------------------------------------------------------------------*/\n\n//If you are using ZERO_TRACKER_ODOM, you ONLY need to adjust the FORWARD TRACKER CENTER DISTANCE.\n\n//FOR HOLONOMIC DRIVES ONLY: Input your drive motors by position. This is only necessary for holonomic drives, otherwise this section can be left alone.\n//LF:      //RF:    \nPORT1,     -PORT2,\n\n//LB:      //RB: \nPORT3,     -PORT4,\n\n//If you are using position tracking, this is the Forward Tracker port (the tracker which runs parallel to the direction of the chassis).\n//If this is a rotation sensor, enter it in "PORT1" format, inputting the port below.\n//If this is an encoder, enter the port as an integer. Triport A will be a "1", Triport B will be a "2", etc.\n3,\n\n//Input the Forward Tracker diameter (reverse it to make the direction switch):\n2.75,\n\n//Input Forward Tracker center distance (a positive distance corresponds to a tracker on the right side of the robot, negative is left.)\n//For a zero tracker tank drive with odom, put the positive distance from the center of the robot to the right side of the drive.\n//This distance is in inches:\n5.25,\n\n//Input the Sideways Tracker Port, following the same steps as the Forward Tracker Port:\n5,\n\n//Sideways tracker diameter (reverse to make the direction switch):\n-2.75,\n\n//Sideways tracker center distance (positive distance is behind the center of the robot, negative is in front):\n2.5\n\n);\n'))),(0,n.yg)(i.A,{value:"proto",mdxType:"TabItem"},(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-cpp"},"Drive::Drive(enum::drive_setup drive_setup, motor_group DriveL, motor_group DriveR, int gyro_port, float wheel_diameter, float wheel_ratio, float gyro_scale, int DriveLF_port, int DriveRF_port, int DriveLB_port, int DriveRB_port, int ForwardTracker_port, float ForwardTracker_diameter, float ForwardTracker_center_distance, int SidewaysTracker_port, float SidewaysTracker_diameter, float SidewaysTracker_center_distance);\n")))),(0,n.yg)("h3",{id:"tank_one_sideways_rotation"},"TANK_ONE_SIDEWAYS_ROTATION"),(0,n.yg)("p",null,"This style of odometry uses the right side motor encoders to measure forward/backward movement and a V5 rotation sensor to measure sideways movement."),(0,n.yg)(a.A,{groupId:"tank_one_sideways_rotation",defaultValue:"proto",values:[{label:"Prototype",value:"proto"},{label:"Example",value:"example"}],mdxType:"Tabs"},(0,n.yg)(i.A,{value:"example",mdxType:"TabItem"},(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-cpp"},'Drive chassis(\n\n//Pick your drive setup from the list below:\n//ZERO_TRACKER_NO_ODOM\n//ZERO_TRACKER_ODOM\n//TANK_ONE_FORWARD_ENCODER\n//TANK_ONE_FORWARD_ROTATION\n//TANK_ONE_SIDEWAYS_ENCODER\n//TANK_ONE_SIDEWAYS_ROTATION\n//TANK_TWO_ENCODER\n//TANK_TWO_ROTATION\n//HOLONOMIC_TWO_ENCODER\n//HOLONOMIC_TWO_ROTATION\n//\n//Write it here:\nTANK_ONE_SIDEWAYS_ROTATION,\n\n//Add the names of your Drive motors into the motor groups below, separated by commas, i.e. motor_group(Motor1,Motor2,Motor3).\n//You will input whatever motor names you chose when you configured your robot using the sidebar configurer, they don\'t have to be "Motor1" and "Motor2".\n\n//Left Motors:\nmotor_group(LeftFront, LeftBack),\n\n//Right Motors:\nmotor_group(RightFront, RightBack),\n\n//Specify the PORT NUMBER of your inertial sensor, in PORT format (i.e. "PORT1", not simply "1"):\nPORT4,\n\n//Input your wheel diameter. (4" omnis are actually closer to 4.125"):\n4.125,\n\n//External ratio, must be in decimal, in the format of input teeth/output teeth.\n//If your motor has an 84-tooth gear and your wheel has a 60-tooth gear, this value will be 1.4.\n//If the motor drives the wheel directly, this value is 1:\n1.0,\n\n//Gyro scale, this is what your gyro reads when you spin the robot 360 degrees.\n//For most cases 360 will do fine here, but this scale factor can be very helpful when precision is necessary.\n360,\n\n/*---------------------------------------------------------------------------*/\n/*                                  PAUSE!                                   */\n/*                                                                           */\n/*  The rest of the drive constructor is for robots using POSITION TRACKING. */\n/*  If you are not using position tracking, leave the rest of the values as  */\n/*  they are.                                                                */\n/*---------------------------------------------------------------------------*/\n\n//If you are using ZERO_TRACKER_ODOM, you ONLY need to adjust the FORWARD TRACKER CENTER DISTANCE.\n\n//FOR HOLONOMIC DRIVES ONLY: Input your drive motors by position. This is only necessary for holonomic drives, otherwise this section can be left alone.\n//LF:      //RF:    \nPORT1,     -PORT2,\n\n//LB:      //RB: \nPORT3,     -PORT4,\n\n//If you are using position tracking, this is the Forward Tracker port (the tracker which runs parallel to the direction of the chassis).\n//If this is a rotation sensor, enter it in "PORT1" format, inputting the port below.\n//If this is an encoder, enter the port as an integer. Triport A will be a "1", Triport B will be a "2", etc.\n3,\n\n//Input the Forward Tracker diameter (reverse it to make the direction switch):\n2.75,\n\n//Input Forward Tracker center distance (a positive distance corresponds to a tracker on the right side of the robot, negative is left.)\n//For a zero tracker tank drive with odom, put the positive distance from the center of the robot to the right side of the drive.\n//This distance is in inches:\n5.25,\n\n//Input the Sideways Tracker Port, following the same steps as the Forward Tracker Port:\nPORT17,\n\n//Sideways tracker diameter (reverse to make the direction switch):\n-2.75,\n\n//Sideways tracker center distance (positive distance is behind the center of the robot, negative is in front):\n2.5\n\n);\n'))),(0,n.yg)(i.A,{value:"proto",mdxType:"TabItem"},(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-cpp"},"Drive::Drive(enum::drive_setup drive_setup, motor_group DriveL, motor_group DriveR, int gyro_port, float wheel_diameter, float wheel_ratio, float gyro_scale, int DriveLF_port, int DriveRF_port, int DriveLB_port, int DriveRB_port, int ForwardTracker_port, float ForwardTracker_diameter, float ForwardTracker_center_distance, int SidewaysTracker_port, float SidewaysTracker_diameter, float SidewaysTracker_center_distance);\n")))),(0,n.yg)("h3",{id:"tank_two_encoder"},"TANK_TWO_ENCODER"),(0,n.yg)("p",null,"These tracking wheels must be perpendicular to each other. The Forward Tracker is parallel to the direction of travel, and the Sideways Tracker is perpendicular to the direction of travel. See the note above about optical encoder wiring."),(0,n.yg)(a.A,{groupId:"tank_two_encoder",defaultValue:"proto",values:[{label:"Prototype",value:"proto"},{label:"Example",value:"example"}],mdxType:"Tabs"},(0,n.yg)(i.A,{value:"example",mdxType:"TabItem"},(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-cpp"},'Drive chassis(\n\n//Pick your drive setup from the list below:\n//ZERO_TRACKER_NO_ODOM\n//ZERO_TRACKER_ODOM\n//TANK_ONE_FORWARD_ENCODER\n//TANK_ONE_FORWARD_ROTATION\n//TANK_ONE_SIDEWAYS_ENCODER\n//TANK_ONE_SIDEWAYS_ROTATION\n//TANK_TWO_ENCODER\n//TANK_TWO_ROTATION\n//HOLONOMIC_TWO_ENCODER\n//HOLONOMIC_TWO_ROTATION\n//\n//Write it here:\nTANK_TWO_ENCODER,\n\n//Add the names of your Drive motors into the motor groups below, separated by commas, i.e. motor_group(Motor1,Motor2,Motor3).\n//You will input whatever motor names you chose when you configured your robot using the sidebar configurer, they don\'t have to be "Motor1" and "Motor2".\n\n//Left Motors:\nmotor_group(LeftFront, LeftBack),\n\n//Right Motors:\nmotor_group(RightFront, RightBack),\n\n//Specify the PORT NUMBER of your inertial sensor, in PORT format (i.e. "PORT1", not simply "1"):\nPORT4,\n\n//Input your wheel diameter. (4" omnis are actually closer to 4.125"):\n4.125,\n\n//External ratio, must be in decimal, in the format of input teeth/output teeth.\n//If your motor has an 84-tooth gear and your wheel has a 60-tooth gear, this value will be 1.4.\n//If the motor drives the wheel directly, this value is 1:\n1.0,\n\n//Gyro scale, this is what your gyro reads when you spin the robot 360 degrees.\n//For most cases 360 will do fine here, but this scale factor can be very helpful when precision is necessary.\n360,\n\n/*---------------------------------------------------------------------------*/\n/*                                  PAUSE!                                   */\n/*                                                                           */\n/*  The rest of the drive constructor is for robots using POSITION TRACKING. */\n/*  If you are not using position tracking, leave the rest of the values as  */\n/*  they are.                                                                */\n/*---------------------------------------------------------------------------*/\n\n//If you are using ZERO_TRACKER_ODOM, you ONLY need to adjust the FORWARD TRACKER CENTER DISTANCE.\n\n//FOR HOLONOMIC DRIVES ONLY: Input your drive motors by position. This is only necessary for holonomic drives, otherwise this section can be left alone.\n//LF:      //RF:    \nPORT1,     -PORT2,\n\n//LB:      //RB: \nPORT3,     -PORT4,\n\n//If you are using position tracking, this is the Forward Tracker port (the tracker which runs parallel to the direction of the chassis).\n//If this is a rotation sensor, enter it in "PORT1" format, inputting the port below.\n//If this is an encoder, enter the port as an integer. Triport A will be a "1", Triport B will be a "2", etc.\n3,\n\n//Input the Forward Tracker diameter (reverse it to make the direction switch):\n2.75,\n\n//Input Forward Tracker center distance (a positive distance corresponds to a tracker on the right side of the robot, negative is left.)\n//For a zero tracker tank drive with odom, put the positive distance from the center of the robot to the right side of the drive.\n//This distance is in inches:\n5.25,\n\n//Input the Sideways Tracker Port, following the same steps as the Forward Tracker Port:\n5,\n\n//Sideways tracker diameter (reverse to make the direction switch):\n-2.75,\n\n//Sideways tracker center distance (positive distance is behind the center of the robot, negative is in front):\n2.5\n\n);\n'))),(0,n.yg)(i.A,{value:"proto",mdxType:"TabItem"},(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-cpp"},"Drive::Drive(enum::drive_setup drive_setup, motor_group DriveL, motor_group DriveR, int gyro_port, float wheel_diameter, float wheel_ratio, float gyro_scale, int DriveLF_port, int DriveRF_port, int DriveLB_port, int DriveRB_port, int ForwardTracker_port, float ForwardTracker_diameter, float ForwardTracker_center_distance, int SidewaysTracker_port, float SidewaysTracker_diameter, float SidewaysTracker_center_distance);\n")))),(0,n.yg)("h3",{id:"tank_two_rotation"},"TANK_TWO_ROTATION"),(0,n.yg)("p",null,'These tracking wheels must be perpendicular to each other. The Forward Tracker is parallel to the direction of travel, and the Sideways Tracker is perpendicular to the direction of travel. Remember to put the Forward and Sideways Tracker ports in "PORT1" format.'),(0,n.yg)(a.A,{groupId:"tank_two_rotation",defaultValue:"proto",values:[{label:"Prototype",value:"proto"},{label:"Example",value:"example"}],mdxType:"Tabs"},(0,n.yg)(i.A,{value:"example",mdxType:"TabItem"},(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-cpp"},'Drive chassis(\n\n//Pick your drive setup from the list below:\n//ZERO_TRACKER_NO_ODOM\n//ZERO_TRACKER_ODOM\n//TANK_ONE_FORWARD_ENCODER\n//TANK_ONE_FORWARD_ROTATION\n//TANK_ONE_SIDEWAYS_ENCODER\n//TANK_ONE_SIDEWAYS_ROTATION\n//TANK_TWO_ENCODER\n//TANK_TWO_ROTATION\n//HOLONOMIC_TWO_ENCODER\n//HOLONOMIC_TWO_ROTATION\n//\n//Write it here:\nTANK_TWO_ROTATION,\n\n//Add the names of your Drive motors into the motor groups below, separated by commas, i.e. motor_group(Motor1,Motor2,Motor3).\n//You will input whatever motor names you chose when you configured your robot using the sidebar configurer, they don\'t have to be "Motor1" and "Motor2".\n\n//Left Motors:\nmotor_group(LeftFront, LeftBack),\n\n//Right Motors:\nmotor_group(RightFront, RightBack),\n\n//Specify the PORT NUMBER of your inertial sensor, in PORT format (i.e. "PORT1", not simply "1"):\nPORT4,\n\n//Input your wheel diameter. (4" omnis are actually closer to 4.125"):\n4.125,\n\n//External ratio, must be in decimal, in the format of input teeth/output teeth.\n//If your motor has an 84-tooth gear and your wheel has a 60-tooth gear, this value will be 1.4.\n//If the motor drives the wheel directly, this value is 1:\n1.0,\n\n//Gyro scale, this is what your gyro reads when you spin the robot 360 degrees.\n//For most cases 360 will do fine here, but this scale factor can be very helpful when precision is necessary.\n360,\n\n/*---------------------------------------------------------------------------*/\n/*                                  PAUSE!                                   */\n/*                                                                           */\n/*  The rest of the drive constructor is for robots using POSITION TRACKING. */\n/*  If you are not using position tracking, leave the rest of the values as  */\n/*  they are.                                                                */\n/*---------------------------------------------------------------------------*/\n\n//If you are using ZERO_TRACKER_ODOM, you ONLY need to adjust the FORWARD TRACKER CENTER DISTANCE.\n\n//FOR HOLONOMIC DRIVES ONLY: Input your drive motors by position. This is only necessary for holonomic drives, otherwise this section can be left alone.\n//LF:      //RF:    \nPORT1,     -PORT2,\n\n//LB:      //RB: \nPORT3,     -PORT4,\n\n//If you are using position tracking, this is the Forward Tracker port (the tracker which runs parallel to the direction of the chassis).\n//If this is a rotation sensor, enter it in "PORT1" format, inputting the port below.\n//If this is an encoder, enter the port as an integer. Triport A will be a "1", Triport B will be a "2", etc.\nPORT18,\n\n//Input the Forward Tracker diameter (reverse it to make the direction switch):\n2.75,\n\n//Input Forward Tracker center distance (a positive distance corresponds to a tracker on the right side of the robot, negative is left.)\n//For a zero tracker tank drive with odom, put the positive distance from the center of the robot to the right side of the drive.\n//This distance is in inches:\n5.25,\n\n//Input the Sideways Tracker Port, following the same steps as the Forward Tracker Port:\nPORT17,\n\n//Sideways tracker diameter (reverse to make the direction switch):\n-2.75,\n\n//Sideways tracker center distance (positive distance is behind the center of the robot, negative is in front):\n2.5\n\n);\n'))),(0,n.yg)(i.A,{value:"proto",mdxType:"TabItem"},(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-cpp"},"Drive::Drive(enum::drive_setup drive_setup, motor_group DriveL, motor_group DriveR, int gyro_port, float wheel_diameter, float wheel_ratio, float gyro_scale, int DriveLF_port, int DriveRF_port, int DriveLB_port, int DriveRB_port, int ForwardTracker_port, float ForwardTracker_diameter, float ForwardTracker_center_distance, int SidewaysTracker_port, float SidewaysTracker_diameter, float SidewaysTracker_center_distance);\n")))),(0,n.yg)("h3",{id:"holonomic_two_encoder"},"HOLONOMIC_TWO_ENCODER"),(0,n.yg)("p",null,"This setup only works with a four motor X-Drive or mecanum drive. These tracking wheels must be perpendicular to each other. The Forward Tracker is parallel to the direction of travel, and the Sideways Tracker is perpendicular to the direction of travel. See the note above about optical encoder wiring."),(0,n.yg)(a.A,{groupId:"holonomic_two_encoder",defaultValue:"proto",values:[{label:"Prototype",value:"proto"},{label:"Example",value:"example"}],mdxType:"Tabs"},(0,n.yg)(i.A,{value:"example",mdxType:"TabItem"},(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-cpp"},'Drive chassis(\n\n//Pick your drive setup from the list below:\n//ZERO_TRACKER_NO_ODOM\n//ZERO_TRACKER_ODOM\n//TANK_ONE_FORWARD_ENCODER\n//TANK_ONE_FORWARD_ROTATION\n//TANK_ONE_SIDEWAYS_ENCODER\n//TANK_ONE_SIDEWAYS_ROTATION\n//TANK_TWO_ENCODER\n//TANK_TWO_ROTATION\n//HOLONOMIC_TWO_ENCODER\n//HOLONOMIC_TWO_ROTATION\n//\n//Write it here:\nHOLONOMIC_TWO_ENCODER,\n\n//Add the names of your Drive motors into the motor groups below, separated by commas, i.e. motor_group(Motor1,Motor2,Motor3).\n//You will input whatever motor names you chose when you configured your robot using the sidebar configurer, they don\'t have to be "Motor1" and "Motor2".\n\n//Left Motors:\nmotor_group(LeftFront, LeftBack),\n\n//Right Motors:\nmotor_group(RightFront, RightBack),\n\n//Specify the PORT NUMBER of your inertial sensor, in PORT format (i.e. "PORT1", not simply "1"):\nPORT4,\n\n//Input your wheel diameter. (4" omnis are actually closer to 4.125"):\n4.125,\n\n//External ratio, must be in decimal, in the format of input teeth/output teeth.\n//If your motor has an 84-tooth gear and your wheel has a 60-tooth gear, this value will be 1.4.\n//If the motor drives the wheel directly, this value is 1:\n1.0,\n\n//Gyro scale, this is what your gyro reads when you spin the robot 360 degrees.\n//For most cases 360 will do fine here, but this scale factor can be very helpful when precision is necessary.\n360,\n\n/*---------------------------------------------------------------------------*/\n/*                                  PAUSE!                                   */\n/*                                                                           */\n/*  The rest of the drive constructor is for robots using POSITION TRACKING. */\n/*  If you are not using position tracking, leave the rest of the values as  */\n/*  they are.                                                                */\n/*---------------------------------------------------------------------------*/\n\n//If you are using ZERO_TRACKER_ODOM, you ONLY need to adjust the FORWARD TRACKER CENTER DISTANCE.\n\n//FOR HOLONOMIC DRIVES ONLY: Input your drive motors by position. This is only necessary for holonomic drives, otherwise this section can be left alone.\n//LF:      //RF:    \nPORT15,     -PORT17,\n\n//LB:      //RB: \nPORT16,     -PORT18,\n\n//If you are using position tracking, this is the Forward Tracker port (the tracker which runs parallel to the direction of the chassis).\n//If this is a rotation sensor, enter it in "PORT1" format, inputting the port below.\n//If this is an encoder, enter the port as an integer. Triport A will be a "1", Triport B will be a "2", etc.\n3,\n\n//Input the Forward Tracker diameter (reverse it to make the direction switch):\n2.75,\n\n//Input Forward Tracker center distance (a positive distance corresponds to a tracker on the right side of the robot, negative is left.)\n//For a zero tracker tank drive with odom, put the positive distance from the center of the robot to the right side of the drive.\n//This distance is in inches:\n5.25,\n\n//Input the Sideways Tracker Port, following the same steps as the Forward Tracker Port:\n5,\n\n//Sideways tracker diameter (reverse to make the direction switch):\n-2.75,\n\n//Sideways tracker center distance (positive distance is behind the center of the robot, negative is in front):\n2.5\n\n);\n'))),(0,n.yg)(i.A,{value:"proto",mdxType:"TabItem"},(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-cpp"},"Drive::Drive(enum::drive_setup drive_setup, motor_group DriveL, motor_group DriveR, int gyro_port, float wheel_diameter, float wheel_ratio, float gyro_scale, int DriveLF_port, int DriveRF_port, int DriveLB_port, int DriveRB_port, int ForwardTracker_port, float ForwardTracker_diameter, float ForwardTracker_center_distance, int SidewaysTracker_port, float SidewaysTracker_diameter, float SidewaysTracker_center_distance);\n")))),(0,n.yg)("h3",{id:"holonomic_two_rotation"},"HOLONOMIC_TWO_ROTATION"),(0,n.yg)("p",null,'This setup only works with a four motor X-Drive or mecanum drive. These tracking wheels must be perpendicular to each other. The Forward Tracker is parallel to the direction of travel, and the Sideways Tracker is perpendicular to the direction of travel. Remember to put the Forward and Sideways Tracker ports in "PORT1" format.'),(0,n.yg)(a.A,{groupId:"holonomic_two_rotation",defaultValue:"proto",values:[{label:"Prototype",value:"proto"},{label:"Example",value:"example"}],mdxType:"Tabs"},(0,n.yg)(i.A,{value:"example",mdxType:"TabItem"},(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-cpp"},'Drive chassis(\n\n//Pick your drive setup from the list below:\n//ZERO_TRACKER_NO_ODOM\n//ZERO_TRACKER_ODOM\n//TANK_ONE_FORWARD_ENCODER\n//TANK_ONE_FORWARD_ROTATION\n//TANK_ONE_SIDEWAYS_ENCODER\n//TANK_ONE_SIDEWAYS_ROTATION\n//TANK_TWO_ENCODER\n//TANK_TWO_ROTATION\n//HOLONOMIC_TWO_ENCODER\n//HOLONOMIC_TWO_ROTATION\n//\n//Write it here:\nHOLONOMIC_TWO_ROTATION,\n\n//Add the names of your Drive motors into the motor groups below, separated by commas, i.e. motor_group(Motor1,Motor2,Motor3).\n//You will input whatever motor names you chose when you configured your robot using the sidebar configurer, they don\'t have to be "Motor1" and "Motor2".\n\n//Left Motors:\nmotor_group(LeftFront, LeftBack),\n\n//Right Motors:\nmotor_group(RightFront, RightBack),\n\n//Specify the PORT NUMBER of your inertial sensor, in PORT format (i.e. "PORT1", not simply "1"):\nPORT4,\n\n//Input your wheel diameter. (4" omnis are actually closer to 4.125"):\n4.125,\n\n//External ratio, must be in decimal, in the format of input teeth/output teeth.\n//If your motor has an 84-tooth gear and your wheel has a 60-tooth gear, this value will be 1.4.\n//If the motor drives the wheel directly, this value is 1:\n1.0,\n\n//Gyro scale, this is what your gyro reads when you spin the robot 360 degrees.\n//For most cases 360 will do fine here, but this scale factor can be very helpful when precision is necessary.\n360,\n\n/*---------------------------------------------------------------------------*/\n/*                                  PAUSE!                                   */\n/*                                                                           */\n/*  The rest of the drive constructor is for robots using POSITION TRACKING. */\n/*  If you are not using position tracking, leave the rest of the values as  */\n/*  they are.                                                                */\n/*---------------------------------------------------------------------------*/\n\n//If you are using ZERO_TRACKER_ODOM, you ONLY need to adjust the FORWARD TRACKER CENTER DISTANCE.\n\n//FOR HOLONOMIC DRIVES ONLY: Input your drive motors by position. This is only necessary for holonomic drives, otherwise this section can be left alone.\n//LF:      //RF:    \nPORT15,     -PORT17,\n\n//LB:      //RB: \nPORT16,     -PORT18,\n\n//If you are using position tracking, this is the Forward Tracker port (the tracker which runs parallel to the direction of the chassis).\n//If this is a rotation sensor, enter it in "PORT1" format, inputting the port below.\n//If this is an encoder, enter the port as an integer. Triport A will be a "1", Triport B will be a "2", etc.\nPORT8,\n\n//Input the Forward Tracker diameter (reverse it to make the direction switch):\n2.75,\n\n//Input Forward Tracker center distance (a positive distance corresponds to a tracker on the right side of the robot, negative is left.)\n//For a zero tracker tank drive with odom, put the positive distance from the center of the robot to the right side of the drive.\n//This distance is in inches:\n5.25,\n\n//Input the Sideways Tracker Port, following the same steps as the Forward Tracker Port:\nPORT9,\n\n//Sideways tracker diameter (reverse to make the direction switch):\n-2.75,\n\n//Sideways tracker center distance (positive distance is behind the center of the robot, negative is in front):\n2.5\n\n);\n'))),(0,n.yg)(i.A,{value:"proto",mdxType:"TabItem"},(0,n.yg)("pre",null,(0,n.yg)("code",{parentName:"pre",className:"language-cpp"},"Drive::Drive(enum::drive_setup drive_setup, motor_group DriveL, motor_group DriveR, int gyro_port, float wheel_diameter, float wheel_ratio, float gyro_scale, int DriveLF_port, int DriveRF_port, int DriveLB_port, int DriveRB_port, int ForwardTracker_port, float ForwardTracker_diameter, float ForwardTracker_center_distance, int SidewaysTracker_port, float SidewaysTracker_diameter, float SidewaysTracker_center_distance);\n")))),(0,n.yg)("h2",{id:"on-gyro-scale"},"On Gyro Scale"),(0,n.yg)("h3",{id:"intuition"},"Intuition"),(0,n.yg)("p",null,"The gyro scale parameter is often the least intuitive parameter in the drive constructor, but it serves a particularly important purpose."),(0,n.yg)("p",null,"You may have noticed that V5 IMU sensors often display a bit of error. For example, even if you spin the robot around by a perfect 360 degrees, the sensor's output may say 358.5 every single time. Try it yourself. On most vex gyroscopes, you will get a consistent one or two degrees of error per rotation every time. This adds up, so a robot that reads 359 degrees after one spin will read 350 degrees after ten spins."),(0,n.yg)("p",null,"One solution is to keep trying new gyros until you find one that's as close to perfect as possible, and this is a lot of teams' go-to method. But I propose a new one. Just multiply the gyro's output by a small scale factor to make the robots rotation equal to 360 degrees every single time. This will negate the effect of the gyro's error and make your runs look good as new."),(0,n.yg)("h3",{id:"usage"},"Usage"),(0,n.yg)("p",null,"Open the devices menu and select your gyroscope. Ensure it reads 0 (or approximately 0), and spin the robot around a full rotation. Note the reading now displayed on the devices menu. If it is a bit less than 360, that's your number. If it is a bit more than 0, add 360 and that's your number. Input that number as the gyro scale in the drive constructor."))}m.isMDXComponent=!0}}]);