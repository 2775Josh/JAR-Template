"use strict";(self.webpackChunksite=self.webpackChunksite||[]).push([[703],{3905:(e,t,r)=>{r.d(t,{Zo:()=>u,kt:()=>m});var o=r(7294);function n(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,o)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){n(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,o,n=function(e,t){if(null==e)return{};var r,o,n={},a=Object.keys(e);for(o=0;o<a.length;o++)r=a[o],t.indexOf(r)>=0||(n[r]=e[r]);return n}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)r=a[o],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}var l=o.createContext({}),c=function(e){var t=o.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},u=function(e){var t=c(e.components);return o.createElement(l.Provider,{value:t},e.children)},h="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},p=o.forwardRef((function(e,t){var r=e.components,n=e.mdxType,a=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),h=c(r),p=n,m=h["".concat(l,".").concat(p)]||h[p]||d[p]||a;return r?o.createElement(m,i(i({ref:t},u),{},{components:r})):o.createElement(m,i({ref:t},u))}));function m(e,t){var r=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var a=r.length,i=new Array(a);i[0]=p;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[h]="string"==typeof e?e:n,i[1]=s;for(var c=2;c<a;c++)i[c]=r[c];return o.createElement.apply(null,i)}return o.createElement.apply(null,r)}p.displayName="MDXCreateElement"},5162:(e,t,r)=>{r.d(t,{Z:()=>i});var o=r(7294),n=r(6010);const a={tabItem:"tabItem_Ymn6"};function i(e){let{children:t,hidden:r,className:i}=e;return o.createElement("div",{role:"tabpanel",className:(0,n.Z)(a.tabItem,i),hidden:r},t)}},4866:(e,t,r)=>{r.d(t,{Z:()=>_});var o=r(7462),n=r(7294),a=r(6010),i=r(2466),s=r(6550),l=r(1980),c=r(7392),u=r(12);function h(e){return function(e){return n.Children.map(e,(e=>{if(!e||(0,n.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}(e).map((e=>{let{props:{value:t,label:r,attributes:o,default:n}}=e;return{value:t,label:r,attributes:o,default:n}}))}function d(e){const{values:t,children:r}=e;return(0,n.useMemo)((()=>{const e=t??h(r);return function(e){const t=(0,c.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,r])}function p(e){let{value:t,tabValues:r}=e;return r.some((e=>e.value===t))}function m(e){let{queryString:t=!1,groupId:r}=e;const o=(0,s.k6)(),a=function(e){let{queryString:t=!1,groupId:r}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!r)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return r??null}({queryString:t,groupId:r});return[(0,l._X)(a),(0,n.useCallback)((e=>{if(!a)return;const t=new URLSearchParams(o.location.search);t.set(a,e),o.replace({...o.location,search:t.toString()})}),[a,o])]}function T(e){const{defaultValue:t,queryString:r=!1,groupId:o}=e,a=d(e),[i,s]=(0,n.useState)((()=>function(e){let{defaultValue:t,tabValues:r}=e;if(0===r.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!p({value:t,tabValues:r}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${r.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const o=r.find((e=>e.default))??r[0];if(!o)throw new Error("Unexpected error: 0 tabValues");return o.value}({defaultValue:t,tabValues:a}))),[l,c]=m({queryString:r,groupId:o}),[h,T]=function(e){let{groupId:t}=e;const r=function(e){return e?`docusaurus.tab.${e}`:null}(t),[o,a]=(0,u.Nk)(r);return[o,(0,n.useCallback)((e=>{r&&a.set(e)}),[r,a])]}({groupId:o}),f=(()=>{const e=l??h;return p({value:e,tabValues:a})?e:null})();(0,n.useLayoutEffect)((()=>{f&&s(f)}),[f]);return{selectedValue:i,selectValue:(0,n.useCallback)((e=>{if(!p({value:e,tabValues:a}))throw new Error(`Can't select invalid tab value=${e}`);s(e),c(e),T(e)}),[c,T,a]),tabValues:a}}var f=r(2389);const y={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function O(e){let{className:t,block:r,selectedValue:s,selectValue:l,tabValues:c}=e;const u=[],{blockElementScrollPositionUntilNextRender:h}=(0,i.o5)(),d=e=>{const t=e.currentTarget,r=u.indexOf(t),o=c[r].value;o!==s&&(h(t),l(o))},p=e=>{let t=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const r=u.indexOf(e.currentTarget)+1;t=u[r]??u[0];break}case"ArrowLeft":{const r=u.indexOf(e.currentTarget)-1;t=u[r]??u[u.length-1];break}}t?.focus()};return n.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,a.Z)("tabs",{"tabs--block":r},t)},c.map((e=>{let{value:t,label:r,attributes:i}=e;return n.createElement("li",(0,o.Z)({role:"tab",tabIndex:s===t?0:-1,"aria-selected":s===t,key:t,ref:e=>u.push(e),onKeyDown:p,onClick:d},i,{className:(0,a.Z)("tabs__item",y.tabItem,i?.className,{"tabs__item--active":s===t})}),r??t)})))}function v(e){let{lazy:t,children:r,selectedValue:o}=e;const a=(Array.isArray(r)?r:[r]).filter(Boolean);if(t){const e=a.find((e=>e.props.value===o));return e?(0,n.cloneElement)(e,{className:"margin-top--md"}):null}return n.createElement("div",{className:"margin-top--md"},a.map(((e,t)=>(0,n.cloneElement)(e,{key:t,hidden:e.props.value!==o}))))}function w(e){const t=T(e);return n.createElement("div",{className:(0,a.Z)("tabs-container",y.tabList)},n.createElement(O,(0,o.Z)({},e,t)),n.createElement(v,(0,o.Z)({},e,t)))}function _(e){const t=(0,f.Z)();return n.createElement(w,(0,o.Z)({key:String(t)},e))}},5676:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>u,contentTitle:()=>l,default:()=>m,frontMatter:()=>s,metadata:()=>c,toc:()=>h});var o=r(7462),n=(r(7294),r(3905)),a=r(4866),i=r(5162);const s={sidebar_position:1,sidebar_label:"Drive Constructor",title:"Drive Constructor"},l=void 0,c={unversionedId:"docs/drive-constructor",id:"docs/drive-constructor",title:"Drive Constructor",description:"The JAR Template drive constructor can build drivetrains with no tracking wheels, but also supports tank and holonomic odometry, with either red optical encoders or V5 rotation sensors. Note that each constructor has the same prototype, and that every drive style requires a V5 inertial sensor.",source:"@site/docs/docs/drive-constructor.md",sourceDirName:"docs",slug:"/docs/drive-constructor",permalink:"/JAR-Template/docs/drive-constructor",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,sidebar_label:"Drive Constructor",title:"Drive Constructor"},sidebar:"tutorialSidebar",previous:{title:"Docs",permalink:"/JAR-Template/docs/"},next:{title:"Usercontrol Functions",permalink:"/JAR-Template/docs/usercontrol-functions"}},u={},h=[{value:"No Tracking Wheels without Odometry",id:"no-tracking-wheels-without-odometry",level:2},{value:"No Tracking Wheels with Odometry",id:"no-tracking-wheels-with-odometry",level:2},{value:"One Red Optical Encoder on a Tank Drive",id:"one-red-optical-encoder-on-a-tank-drive",level:2},{value:"One V5 Rotation Sensor on a Tank Drive",id:"one-v5-rotation-sensor-on-a-tank-drive",level:2},{value:"Two Red Optical Encoders on a Tank Drive",id:"two-red-optical-encoders-on-a-tank-drive",level:2},{value:"Two V5 Rotation Sensors on a Tank Drive",id:"two-v5-rotation-sensors-on-a-tank-drive",level:2},{value:"Two Red Optical Encoders on a Holonomic Drive",id:"two-red-optical-encoders-on-a-holonomic-drive",level:2},{value:"Two V5 Rotation Sensors on a Holonomic Drive",id:"two-v5-rotation-sensors-on-a-holonomic-drive",level:2}],d={toc:h},p="wrapper";function m(e){let{components:t,...r}=e;return(0,n.kt)(p,(0,o.Z)({},d,r,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("p",null,"The JAR Template drive constructor can build drivetrains with no tracking wheels, but also supports tank and holonomic odometry, with either red optical encoders or V5 rotation sensors. Note that each constructor has the same prototype, and that every drive style ",(0,n.kt)("strong",{parentName:"p"},"requires")," a V5 inertial sensor."),(0,n.kt)("admonition",{type:"caution"},(0,n.kt)("p",{parentName:"admonition"},(0,n.kt)("strong",{parentName:"p"},"Do not try to add extra motor groups, sensors, or values to the constructor or to remove any that you do not need. The code will not compile. Follow the style of the examples, only filling in fields that are already present."))),(0,n.kt)("admonition",{type:"note"},(0,n.kt)("p",{parentName:"admonition"},'For odometry users using red optical encoders: the top wire of the encoder is always plugged in one port above the bottom wire, and it is the top wire that is indicated in VexCode. So putting the port as "3" means that the encoder is plugged into triports C and D on the brain with the top wire in port C and the bottom wire in port D. Likewise, putting the port as "5" means the encoder is plugged into ports E and F.')),(0,n.kt)("h2",{id:"no-tracking-wheels-without-odometry"},"No Tracking Wheels without Odometry"),(0,n.kt)("p",null,(0,n.kt)("em",{parentName:"p"},"Corresponds to ZERO_TRACKER_NO_ODOM")),(0,n.kt)("p",null,"Note that for this drive setup, nothing needs to be edited after the gyro scale factor."),(0,n.kt)(a.Z,{groupId:"zero_tracker",defaultValue:"proto",values:[{label:"Prototype",value:"proto"},{label:"Example",value:"example"}],mdxType:"Tabs"},(0,n.kt)(i.Z,{value:"example",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-cpp"},'Drive chassis(\n\n//Specify your drive setup below. There are eight options:\n//ZERO_TRACKER_NO_ODOM, ZERO_TRACKER_ODOM, TANK_ONE_ENCODER, TANK_ONE_ROTATION, TANK_TWO_ENCODER, TANK_TWO_ROTATION, HOLONOMIC_TWO_ENCODER, and HOLONOMIC_TWO_ROTATION\n//For example, if you are not using odometry, put ZERO_TRACKER_NO_ODOM below:\nZERO_TRACKER_NO_ODOM,\n\n//Add the names of your Drive motors into the motor groups below, separated by commas, i.e. motor_group(Motor1,Motor2,Motor3).\n//You will input whatever motor names you chose when you configured your robot using the sidebar configurer, they don\'t have to be "Motor1" and "Motor2".\n\n//Left Motors:\nmotor_group(LeftFront, LeftBack),\n\n//Right Motors:\nmotor_group(RightFront, RightBack),\n\n//Specify the PORT NUMBER of your inertial sensor, in PORT format (i.e. "PORT1", not simply "1"):\nPORT1,\n\n//Input your wheel diameter. (4" omnis are actually closer to 4.125"):\n3.25,\n\n//External ratio, must be in decimal, in the format of input teeth/output teeth.\n//If your motor has an 84-tooth gear and your wheel has a 60-tooth gear, this value will be 1.4.\n//If the motor drives the wheel directly, this value is 1:\n1.6,\n\n//Gyro scale, this is what your gyro reads when you spin the robot 360 degrees.\n//For most cases 360 will do fine here, but this scale factor can be very helpful when precision is necessary.\n360,\n\n/*---------------------------------------------------------------------------*/\n/*                                  PAUSE!                                   */\n/*                                                                           */\n/*  The rest of the drive constructor is for robots using POSITION TRACKING. */\n/*  If you are not using position tracking, leave the rest of the values as  */\n/*  they are.                                                                */\n/*---------------------------------------------------------------------------*/\n\n//PAUSE! The rest of the drive constructor is for robot using POSITION TRACKING.\n//If you are not using position tracking, leave the rest of the values as they are.\n\n//Input your drive motors by position. This is only necessary for holonomic drives, otherwise this section can be left alone.\n//LF:      //RF:    \nPORT1,     -PORT2,\n\n//LB:      //RB: \nPORT3,     -PORT4,\n\n//If you are using position tracking, this is the Forward Tracker port (the tracker which runs parallel to the direction of the chassis).\n//If this is a rotation sensor, leave it in "PORT1" format, inputting the port below.\n//If this is an encoder, enter the port as an integer. Triport A will be a "1", Triport B will be a "2", etc.\n3,\n\n//Input the Forward Tracker diameter (reverse it to make the direction switch):\n2.75,\n\n//Input Forward Tracker center distance (a positive distance corresponds to a tracker on the right side of the robot, negative is left.)\n//This distance is in inches:\n-2,\n\n//Input the Sideways Tracker Port, following the same steps as the Forward Tracker Port:\n1,\n\n//Sideways tracker diameter (reverse to make the direction switch):\n-2.75,\n\n//Sideways tracker center distance (positive distance is behind the center of the robot, negative is in front):\n5.5\n\n);\n'))),(0,n.kt)(i.Z,{value:"proto",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-cpp"},"Drive::Drive(enum::drive_setup drive_setup, motor_group DriveL, motor_group DriveR, int gyro_port, float wheel_diameter, float wheel_ratio, float gyro_scale, int DriveLF_port, int DriveRF_port, int DriveLB_port, int DriveRB_port, int ForwardTracker_port, float ForwardTracker_diameter, float ForwardTracker_center_distance, int SidewaysTracker_port, float SidewaysTracker_diameter, float SidewaysTracker_center_distance);\n")))),(0,n.kt)("h2",{id:"no-tracking-wheels-with-odometry"},"No Tracking Wheels with Odometry"),(0,n.kt)("p",null,(0,n.kt)("em",{parentName:"p"},"Corresponds to ZERO_TRACKER_ODOM")),(0,n.kt)("p",null,"For this drive setup, the only thing that needs to be edited after gyro scale factor is the Forward Tracker Center distance. Since this constructor uses the drive motor encoders to track position, Forward Tracker Center distance is just the distance from the center of your robot to the right set of wheels."),(0,n.kt)(a.Z,{groupId:"zero_tracker_odom",defaultValue:"proto",values:[{label:"Prototype",value:"proto"},{label:"Example",value:"example"}],mdxType:"Tabs"},(0,n.kt)(i.Z,{value:"example",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-cpp"},'Drive chassis(\n\n//Specify your drive setup below. There are eight options:\n//ZERO_TRACKER_NO_ODOM, ZERO_TRACKER_ODOM, TANK_ONE_ENCODER, TANK_ONE_ROTATION, TANK_TWO_ENCODER, TANK_TWO_ROTATION, HOLONOMIC_TWO_ENCODER, and HOLONOMIC_TWO_ROTATION\n//For example, if you are not using odometry, put ZERO_TRACKER_NO_ODOM below:\nZERO_TRACKER_ODOM,\n\n//Add the names of your Drive motors into the motor groups below, separated by commas, i.e. motor_group(Motor1,Motor2,Motor3).\n//You will input whatever motor names you chose when you configured your robot using the sidebar configurer, they don\'t have to be "Motor1" and "Motor2".\n\n//Left Motors:\nmotor_group(LeftFront, LeftBack),\n\n//Right Motors:\nmotor_group(RightFront, RightBack),\n\n//Specify the PORT NUMBER of your inertial sensor, in PORT format (i.e. "PORT1", not simply "1"):\nPORT1,\n\n//Input your wheel diameter. (4" omnis are actually closer to 4.125"):\n3.25,\n\n//External ratio, must be in decimal, in the format of input teeth/output teeth.\n//If your motor has an 84-tooth gear and your wheel has a 60-tooth gear, this value will be 1.4.\n//If the motor drives the wheel directly, this value is 1:\n1.6,\n\n//Gyro scale, this is what your gyro reads when you spin the robot 360 degrees.\n//For most cases 360 will do fine here, but this scale factor can be very helpful when precision is necessary.\n360,\n\n/*---------------------------------------------------------------------------*/\n/*                                  PAUSE!                                   */\n/*                                                                           */\n/*  The rest of the drive constructor is for robots using POSITION TRACKING. */\n/*  If you are not using position tracking, leave the rest of the values as  */\n/*  they are.                                                                */\n/*---------------------------------------------------------------------------*/\n\n//PAUSE! The rest of the drive constructor is for robot using POSITION TRACKING.\n//If you are not using position tracking, leave the rest of the values as they are.\n\n//Input your drive motors by position. This is only necessary for holonomic drives, otherwise this section can be left alone.\n//LF:      //RF:    \nPORT1,     -PORT2,\n\n//LB:      //RB: \nPORT3,     -PORT4,\n\n//If you are using position tracking, this is the Forward Tracker port (the tracker which runs parallel to the direction of the chassis).\n//If this is a rotation sensor, leave it in "PORT1" format, inputting the port below.\n//If this is an encoder, enter the port as an integer. Triport A will be a "1", Triport B will be a "2", etc.\n3,\n\n//Input the Forward Tracker diameter (reverse it to make the direction switch):\n2.75,\n\n//Input Forward Tracker center distance (a positive distance corresponds to a tracker on the right side of the robot, negative is left.)\n//This distance is in inches:\n6,\n\n//Input the Sideways Tracker Port, following the same steps as the Forward Tracker Port:\n1,\n\n//Sideways tracker diameter (reverse to make the direction switch):\n-2.75,\n\n//Sideways tracker center distance (positive distance is behind the center of the robot, negative is in front):\n5.5\n\n);\n'))),(0,n.kt)(i.Z,{value:"proto",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-cpp"},"Drive::Drive(enum::drive_setup drive_setup, motor_group DriveL, motor_group DriveR, int gyro_port, float wheel_diameter, float wheel_ratio, float gyro_scale, int DriveLF_port, int DriveRF_port, int DriveLB_port, int DriveRB_port, int ForwardTracker_port, float ForwardTracker_diameter, float ForwardTracker_center_distance, int SidewaysTracker_port, float SidewaysTracker_diameter, float SidewaysTracker_center_distance);\n")))),(0,n.kt)("h2",{id:"one-red-optical-encoder-on-a-tank-drive"},"One Red Optical Encoder on a Tank Drive"),(0,n.kt)("p",null,(0,n.kt)("em",{parentName:"p"},"Corresponds to TANK_ONE_ENCODER")," "),(0,n.kt)(a.Z,{groupId:"tank_one_encoder",defaultValue:"proto",values:[{label:"Prototype",value:"proto"},{label:"Example",value:"example"}],mdxType:"Tabs"},(0,n.kt)(i.Z,{value:"example",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-cpp"},'Drive chassis(\n\n//Specify your drive setup below. There are eight options:\n//ZERO_TRACKER_NO_ODOM, ZERO_TRACKER_ODOM, TANK_ONE_ENCODER, TANK_ONE_ROTATION, TANK_TWO_ENCODER, TANK_TWO_ROTATION, HOLONOMIC_TWO_ENCODER, and HOLONOMIC_TWO_ROTATION\n//For example, if you are not using odometry, put ZERO_TRACKER_NO_ODOM below:\nTANK_ONE_ENCODER,\n\n//Add the names of your Drive motors into the motor groups below, separated by commas, i.e. motor_group(Motor1,Motor2,Motor3).\n//You will input whatever motor names you chose when you configured your robot using the sidebar configurer, they don\'t have to be "Motor1" and "Motor2".\n\n//Left Motors:\nmotor_group(LeftFront, LeftBack),\n\n//Right Motors:\nmotor_group(RightFront, RightBack),\n\n//Specify the PORT NUMBER of your inertial sensor, in PORT format (i.e. "PORT1", not simply "1"):\nPORT1,\n\n//Input your wheel diameter. (4" omnis are actually closer to 4.125"):\n3.25,\n\n//External ratio, must be in decimal, in the format of input teeth/output teeth.\n//If your motor has an 84-tooth gear and your wheel has a 60-tooth gear, this value will be 1.4.\n//If the motor drives the wheel directly, this value is 1:\n1.6,\n\n//Gyro scale, this is what your gyro reads when you spin the robot 360 degrees.\n//For most cases 360 will do fine here, but this scale factor can be very helpful when precision is necessary.\n360,\n\n/*---------------------------------------------------------------------------*/\n/*                                  PAUSE!                                   */\n/*                                                                           */\n/*  The rest of the drive constructor is for robots using POSITION TRACKING. */\n/*  If you are not using position tracking, leave the rest of the values as  */\n/*  they are.                                                                */\n/*---------------------------------------------------------------------------*/\n\n//PAUSE! The rest of the drive constructor is for robot using POSITION TRACKING.\n//If you are not using position tracking, leave the rest of the values as they are.\n\n//Input your drive motors by position. This is only necessary for holonomic drives, otherwise this section can be left alone.\n//LF:      //RF:    \nPORT1,     -PORT2,\n\n//LB:      //RB: \nPORT3,     -PORT4,\n\n//If you are using position tracking, this is the Forward Tracker port (the tracker which runs parallel to the direction of the chassis).\n//If this is a rotation sensor, leave it in "PORT1" format, inputting the port below.\n//If this is an encoder, enter the port as an integer. Triport A will be a "1", Triport B will be a "2", etc.\n3,\n\n//Input the Forward Tracker diameter (reverse it to make the direction switch):\n2.75,\n\n//Input Forward Tracker center distance (a positive distance corresponds to a tracker on the right side of the robot, negative is left.)\n//This distance is in inches:\n-2,\n\n//Input the Sideways Tracker Port, following the same steps as the Forward Tracker Port:\n1,\n\n//Sideways tracker diameter (reverse to make the direction switch):\n-2.75,\n\n//Sideways tracker center distance (positive distance is behind the center of the robot, negative is in front):\n5.5\n\n);\n'))),(0,n.kt)(i.Z,{value:"proto",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-cpp"},"Drive::Drive(enum::drive_setup drive_setup, motor_group DriveL, motor_group DriveR, int gyro_port, float wheel_diameter, float wheel_ratio, float gyro_scale, int DriveLF_port, int DriveRF_port, int DriveLB_port, int DriveRB_port, int ForwardTracker_port, float ForwardTracker_diameter, float ForwardTracker_center_distance, int SidewaysTracker_port, float SidewaysTracker_diameter, float SidewaysTracker_center_distance);\n")))),(0,n.kt)("p",null,"Typically, this odometry style is used when a tank drive has locked omni wheels. The tracking wheel must be parallel to the direction of travel, and therefore only the constants for the Forward Tracker must be edited from their original state. See the note above about optical encoder wiring."),(0,n.kt)("h2",{id:"one-v5-rotation-sensor-on-a-tank-drive"},"One V5 Rotation Sensor on a Tank Drive"),(0,n.kt)("p",null,(0,n.kt)("em",{parentName:"p"},"Corresponds to TANK_ONE_ROTATION")," "),(0,n.kt)("p",null,'Typically, this odometry style is used when a tank drive has locked omni wheels. The tracking wheel must be parallel to the direction of travel, and therefore only the constants for the Forward Tracker must be edited from their original state. Note that the tracker port must be edited to be in "PORT1" format.'),(0,n.kt)(a.Z,{groupId:"tank_one_rotation",defaultValue:"proto",values:[{label:"Prototype",value:"proto"},{label:"Example",value:"example"}],mdxType:"Tabs"},(0,n.kt)(i.Z,{value:"example",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-cpp"},'Drive chassis(\n\n//Specify your drive setup below. There are eight options:\n//ZERO_TRACKER_NO_ODOM, ZERO_TRACKER_ODOM, TANK_ONE_ENCODER, TANK_ONE_ROTATION, TANK_TWO_ENCODER, TANK_TWO_ROTATION, HOLONOMIC_TWO_ENCODER, and HOLONOMIC_TWO_ROTATION\n//For example, if you are not using odometry, put ZERO_TRACKER_NO_ODOM below:\nTANK_ONE_ROTATION,\n\n//Add the names of your Drive motors into the motor groups below, separated by commas, i.e. motor_group(Motor1,Motor2,Motor3).\n//You will input whatever motor names you chose when you configured your robot using the sidebar configurer, they don\'t have to be "Motor1" and "Motor2".\n\n//Left Motors:\nmotor_group(LeftFront, LeftBack),\n\n//Right Motors:\nmotor_group(RightFront, RightBack),\n\n//Specify the PORT NUMBER of your inertial sensor, in PORT format (i.e. "PORT1", not simply "1"):\nPORT1,\n\n//Input your wheel diameter. (4" omnis are actually closer to 4.125"):\n3.25,\n\n//External ratio, must be in decimal, in the format of input teeth/output teeth.\n//If your motor has an 84-tooth gear and your wheel has a 60-tooth gear, this value will be 1.4.\n//If the motor drives the wheel directly, this value is 1:\n1.6,\n\n//Gyro scale, this is what your gyro reads when you spin the robot 360 degrees.\n//For most cases 360 will do fine here, but this scale factor can be very helpful when precision is necessary.\n360,\n\n/*---------------------------------------------------------------------------*/\n/*                                  PAUSE!                                   */\n/*                                                                           */\n/*  The rest of the drive constructor is for robots using POSITION TRACKING. */\n/*  If you are not using position tracking, leave the rest of the values as  */\n/*  they are.                                                                */\n/*---------------------------------------------------------------------------*/\n\n//PAUSE! The rest of the drive constructor is for robot using POSITION TRACKING.\n//If you are not using position tracking, leave the rest of the values as they are.\n\n//Input your drive motors by position. This is only necessary for holonomic drives, otherwise this section can be left alone.\n//LF:      //RF:    \nPORT1,     -PORT2,\n\n//LB:      //RB: \nPORT3,     -PORT4,\n\n//If you are using position tracking, this is the Forward Tracker port (the tracker which runs parallel to the direction of the chassis).\n//If this is a rotation sensor, leave it in "PORT1" format, inputting the port below.\n//If this is an encoder, enter the port as an integer. Triport A will be a "1", Triport B will be a "2", etc.\nPORT6,\n\n//Input the Forward Tracker diameter (reverse it to make the direction switch):\n2.75,\n\n//Input Forward Tracker center distance (a positive distance corresponds to a tracker on the right side of the robot, negative is left.)\n//This distance is in inches:\n-2,\n\n//Input the Sideways Tracker Port, following the same steps as the Forward Tracker Port:\n1,\n\n//Sideways tracker diameter (reverse to make the direction switch):\n-2.75,\n\n//Sideways tracker center distance (positive distance is behind the center of the robot, negative is in front):\n5.5\n\n);\n'))),(0,n.kt)(i.Z,{value:"proto",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-cpp"},"Drive::Drive(enum::drive_setup drive_setup, motor_group DriveL, motor_group DriveR, int gyro_port, float wheel_diameter, float wheel_ratio, float gyro_scale, int DriveLF_port, int DriveRF_port, int DriveLB_port, int DriveRB_port, int ForwardTracker_port, float ForwardTracker_diameter, float ForwardTracker_center_distance, int SidewaysTracker_port, float SidewaysTracker_diameter, float SidewaysTracker_center_distance);\n")))),(0,n.kt)("h2",{id:"two-red-optical-encoders-on-a-tank-drive"},"Two Red Optical Encoders on a Tank Drive"),(0,n.kt)("p",null,(0,n.kt)("em",{parentName:"p"},"Corresponds to TANK_TWO_ENCODER")," "),(0,n.kt)("p",null,"These tracking wheels must be perpendicular to each other. The Forward Tracker is parallel to the direction of travel, and the Sideways Tracker is perpendicular to the direction of travel. See the note above about optical encoder wiring."),(0,n.kt)(a.Z,{groupId:"tank_two_encoder",defaultValue:"proto",values:[{label:"Prototype",value:"proto"},{label:"Example",value:"example"}],mdxType:"Tabs"},(0,n.kt)(i.Z,{value:"example",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-cpp"},'Drive chassis(\n\n//Specify your drive setup below. There are eight options:\n//ZERO_TRACKER_NO_ODOM, ZERO_TRACKER_ODOM, TANK_ONE_ENCODER, TANK_ONE_ROTATION, TANK_TWO_ENCODER, TANK_TWO_ROTATION, HOLONOMIC_TWO_ENCODER, and HOLONOMIC_TWO_ROTATION\n//For example, if you are not using odometry, put ZERO_TRACKER_NO_ODOM below:\nTANK_TWO_ENCODER,\n\n//Add the names of your Drive motors into the motor groups below, separated by commas, i.e. motor_group(Motor1,Motor2,Motor3).\n//You will input whatever motor names you chose when you configured your robot using the sidebar configurer, they don\'t have to be "Motor1" and "Motor2".\n\n//Left Motors:\nmotor_group(LeftFront, LeftBack),\n\n//Right Motors:\nmotor_group(RightFront, RightBack),\n\n//Specify the PORT NUMBER of your inertial sensor, in PORT format (i.e. "PORT1", not simply "1"):\nPORT1,\n\n//Input your wheel diameter. (4" omnis are actually closer to 4.125"):\n3.25,\n\n//External ratio, must be in decimal, in the format of input teeth/output teeth.\n//If your motor has an 84-tooth gear and your wheel has a 60-tooth gear, this value will be 1.4.\n//If the motor drives the wheel directly, this value is 1:\n1.6,\n\n//Gyro scale, this is what your gyro reads when you spin the robot 360 degrees.\n//For most cases 360 will do fine here, but this scale factor can be very helpful when precision is necessary.\n360,\n\n/*---------------------------------------------------------------------------*/\n/*                                  PAUSE!                                   */\n/*                                                                           */\n/*  The rest of the drive constructor is for robots using POSITION TRACKING. */\n/*  If you are not using position tracking, leave the rest of the values as  */\n/*  they are.                                                                */\n/*---------------------------------------------------------------------------*/\n\n//PAUSE! The rest of the drive constructor is for robot using POSITION TRACKING.\n//If you are not using position tracking, leave the rest of the values as they are.\n\n//Input your drive motors by position. This is only necessary for holonomic drives, otherwise this section can be left alone.\n//LF:      //RF:    \nPORT1,     -PORT2,\n\n//LB:      //RB: \nPORT3,     -PORT4,\n\n//If you are using position tracking, this is the Forward Tracker port (the tracker which runs parallel to the direction of the chassis).\n//If this is a rotation sensor, leave it in "PORT1" format, inputting the port below.\n//If this is an encoder, enter the port as an integer. Triport A will be a "1", Triport B will be a "2", etc.\n3,\n\n//Input the Forward Tracker diameter (reverse it to make the direction switch):\n2.75,\n\n//Input Forward Tracker center distance (a positive distance corresponds to a tracker on the right side of the robot, negative is left.)\n//This distance is in inches:\n-2,\n\n//Input the Sideways Tracker Port, following the same steps as the Forward Tracker Port:\n1,\n\n//Sideways tracker diameter (reverse to make the direction switch):\n-2.75,\n\n//Sideways tracker center distance (positive distance is behind the center of the robot, negative is in front):\n5.5\n\n);\n'))),(0,n.kt)(i.Z,{value:"proto",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-cpp"},"Drive::Drive(enum::drive_setup drive_setup, motor_group DriveL, motor_group DriveR, int gyro_port, float wheel_diameter, float wheel_ratio, float gyro_scale, int DriveLF_port, int DriveRF_port, int DriveLB_port, int DriveRB_port, int ForwardTracker_port, float ForwardTracker_diameter, float ForwardTracker_center_distance, int SidewaysTracker_port, float SidewaysTracker_diameter, float SidewaysTracker_center_distance);\n")))),(0,n.kt)("h2",{id:"two-v5-rotation-sensors-on-a-tank-drive"},"Two V5 Rotation Sensors on a Tank Drive"),(0,n.kt)("p",null,(0,n.kt)("em",{parentName:"p"},"Corresponds to TANK_TWO_ROTATION")," "),(0,n.kt)("p",null,'These tracking wheels must be perpendicular to each other. The Forward Tracker is parallel to the direction of travel, and the Sideways Tracker is perpendicular to the direction of travel. Remember to put the Forward and Sideways Tracker ports in "PORT1" format.'),(0,n.kt)(a.Z,{groupId:"tank_two_rotation",defaultValue:"proto",values:[{label:"Prototype",value:"proto"},{label:"Example",value:"example"}],mdxType:"Tabs"},(0,n.kt)(i.Z,{value:"example",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-cpp"},'Drive chassis(\n\n//Specify your drive setup below. There are eight options:\n//ZERO_TRACKER_NO_ODOM, ZERO_TRACKER_ODOM, TANK_ONE_ENCODER, TANK_ONE_ROTATION, TANK_TWO_ENCODER, TANK_TWO_ROTATION, HOLONOMIC_TWO_ENCODER, and HOLONOMIC_TWO_ROTATION\n//For example, if you are not using odometry, put ZERO_TRACKER_NO_ODOM below:\nTANK_TWO_ROTATION,\n\n//Add the names of your Drive motors into the motor groups below, separated by commas, i.e. motor_group(Motor1,Motor2,Motor3).\n//You will input whatever motor names you chose when you configured your robot using the sidebar configurer, they don\'t have to be "Motor1" and "Motor2".\n\n//Left Motors:\nmotor_group(LeftFront, LeftBack),\n\n//Right Motors:\nmotor_group(RightFront, RightBack),\n\n//Specify the PORT NUMBER of your inertial sensor, in PORT format (i.e. "PORT1", not simply "1"):\nPORT1,\n\n//Input your wheel diameter. (4" omnis are actually closer to 4.125"):\n3.25,\n\n//External ratio, must be in decimal, in the format of input teeth/output teeth.\n//If your motor has an 84-tooth gear and your wheel has a 60-tooth gear, this value will be 1.4.\n//If the motor drives the wheel directly, this value is 1:\n1.6,\n\n//Gyro scale, this is what your gyro reads when you spin the robot 360 degrees.\n//For most cases 360 will do fine here, but this scale factor can be very helpful when precision is necessary.\n360,\n\n/*---------------------------------------------------------------------------*/\n/*                                  PAUSE!                                   */\n/*                                                                           */\n/*  The rest of the drive constructor is for robots using POSITION TRACKING. */\n/*  If you are not using position tracking, leave the rest of the values as  */\n/*  they are.                                                                */\n/*---------------------------------------------------------------------------*/\n\n//PAUSE! The rest of the drive constructor is for robot using POSITION TRACKING.\n//If you are not using position tracking, leave the rest of the values as they are.\n\n//Input your drive motors by position. This is only necessary for holonomic drives, otherwise this section can be left alone.\n//LF:      //RF:    \nPORT1,     -PORT2,\n\n//LB:      //RB: \nPORT3,     -PORT4,\n\n//If you are using position tracking, this is the Forward Tracker port (the tracker which runs parallel to the direction of the chassis).\n//If this is a rotation sensor, leave it in "PORT1" format, inputting the port below.\n//If this is an encoder, enter the port as an integer. Triport A will be a "1", Triport B will be a "2", etc.\nPORT3,\n\n//Input the Forward Tracker diameter (reverse it to make the direction switch):\n2.75,\n\n//Input Forward Tracker center distance (a positive distance corresponds to a tracker on the right side of the robot, negative is left.)\n//This distance is in inches:\n-2,\n\n//Input the Sideways Tracker Port, following the same steps as the Forward Tracker Port:\nPORT6,\n\n//Sideways tracker diameter (reverse to make the direction switch):\n-2.75,\n\n//Sideways tracker center distance (positive distance is behind the center of the robot, negative is in front):\n5.5\n\n);\n'))),(0,n.kt)(i.Z,{value:"proto",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-cpp"},"Drive::Drive(enum::drive_setup drive_setup, motor_group DriveL, motor_group DriveR, int gyro_port, float wheel_diameter, float wheel_ratio, float gyro_scale, int DriveLF_port, int DriveRF_port, int DriveLB_port, int DriveRB_port, int ForwardTracker_port, float ForwardTracker_diameter, float ForwardTracker_center_distance, int SidewaysTracker_port, float SidewaysTracker_diameter, float SidewaysTracker_center_distance);\n")))),(0,n.kt)("h2",{id:"two-red-optical-encoders-on-a-holonomic-drive"},"Two Red Optical Encoders on a Holonomic Drive"),(0,n.kt)("p",null,(0,n.kt)("em",{parentName:"p"},"Corresponds to HOLONOMIC_TWO_ENCODER")," "),(0,n.kt)("p",null,"This setup only works with a four motor X-Drive or mecanum drive. These tracking wheels must be perpendicular to each other. The Forward Tracker is parallel to the direction of travel, and the Sideways Tracker is perpendicular to the direction of travel. See the note above about optical encoder wiring."),(0,n.kt)(a.Z,{groupId:"holonomic_two_encoder",defaultValue:"proto",values:[{label:"Prototype",value:"proto"},{label:"Example",value:"example"}],mdxType:"Tabs"},(0,n.kt)(i.Z,{value:"example",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-cpp"},'Drive chassis(\n\n//Specify your drive setup below. There are eight options:\n//ZERO_TRACKER_NO_ODOM, ZERO_TRACKER_ODOM, TANK_ONE_ENCODER, TANK_ONE_ROTATION, TANK_TWO_ENCODER, TANK_TWO_ROTATION, HOLONOMIC_TWO_ENCODER, and HOLONOMIC_TWO_ROTATION\n//For example, if you are not using odometry, put ZERO_TRACKER_NO_ODOM below:\nHOLONOMIC_TWO_ENCODER,\n\n//Add the names of your Drive motors into the motor groups below, separated by commas, i.e. motor_group(Motor1,Motor2,Motor3).\n//You will input whatever motor names you chose when you configured your robot using the sidebar configurer, they don\'t have to be "Motor1" and "Motor2".\n\n//Left Motors:\nmotor_group(LeftFront, LeftBack),\n\n//Right Motors:\nmotor_group(RightFront, RightBack),\n\n//Specify the PORT NUMBER of your inertial sensor, in PORT format (i.e. "PORT1", not simply "1"):\nPORT1,\n\n//Input your wheel diameter. (4" omnis are actually closer to 4.125"):\n3.25,\n\n//External ratio, must be in decimal, in the format of input teeth/output teeth.\n//If your motor has an 84-tooth gear and your wheel has a 60-tooth gear, this value will be 1.4.\n//If the motor drives the wheel directly, this value is 1:\n1.6,\n\n//Gyro scale, this is what your gyro reads when you spin the robot 360 degrees.\n//For most cases 360 will do fine here, but this scale factor can be very helpful when precision is necessary.\n360,\n\n/*---------------------------------------------------------------------------*/\n/*                                  PAUSE!                                   */\n/*                                                                           */\n/*  The rest of the drive constructor is for robots using POSITION TRACKING. */\n/*  If you are not using position tracking, leave the rest of the values as  */\n/*  they are.                                                                */\n/*---------------------------------------------------------------------------*/\n\n//PAUSE! The rest of the drive constructor is for robot using POSITION TRACKING.\n//If you are not using position tracking, leave the rest of the values as they are.\n\n//Input your drive motors by position. This is only necessary for holonomic drives, otherwise this section can be left alone.\n//LF:      //RF:    \nPORT15,     -PORT16,\n\n//LB:      //RB: \nPORT17,     -PORT18,\n\n//If you are using position tracking, this is the Forward Tracker port (the tracker which runs parallel to the direction of the chassis).\n//If this is a rotation sensor, leave it in "PORT1" format, inputting the port below.\n//If this is an encoder, enter the port as an integer. Triport A will be a "1", Triport B will be a "2", etc.\n3,\n\n//Input the Forward Tracker diameter (reverse it to make the direction switch):\n2.75,\n\n//Input Forward Tracker center distance (a positive distance corresponds to a tracker on the right side of the robot, negative is left.)\n//This distance is in inches:\n-2,\n\n//Input the Sideways Tracker Port, following the same steps as the Forward Tracker Port:\n1,\n\n//Sideways tracker diameter (reverse to make the direction switch):\n-2.75,\n\n//Sideways tracker center distance (positive distance is behind the center of the robot, negative is in front):\n5.5\n\n);\n'))),(0,n.kt)(i.Z,{value:"proto",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-cpp"},"Drive::Drive(enum::drive_setup drive_setup, motor_group DriveL, motor_group DriveR, int gyro_port, float wheel_diameter, float wheel_ratio, float gyro_scale, int DriveLF_port, int DriveRF_port, int DriveLB_port, int DriveRB_port, int ForwardTracker_port, float ForwardTracker_diameter, float ForwardTracker_center_distance, int SidewaysTracker_port, float SidewaysTracker_diameter, float SidewaysTracker_center_distance);\n")))),(0,n.kt)("h2",{id:"two-v5-rotation-sensors-on-a-holonomic-drive"},"Two V5 Rotation Sensors on a Holonomic Drive"),(0,n.kt)("p",null,(0,n.kt)("em",{parentName:"p"},"Corresponds to HOLONOMIC_TWO_ROTATION")," "),(0,n.kt)("p",null,'This setup only works with a four motor X-Drive or mecanum drive. These tracking wheels must be perpendicular to each other. The Forward Tracker is parallel to the direction of travel, and the Sideways Tracker is perpendicular to the direction of travel. Remember to put the Forward and Sideways Tracker ports in "PORT1" format.'),(0,n.kt)(a.Z,{groupId:"holonomic_two_rotation",defaultValue:"proto",values:[{label:"Prototype",value:"proto"},{label:"Example",value:"example"}],mdxType:"Tabs"},(0,n.kt)(i.Z,{value:"example",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-cpp"},'Drive chassis(\n\n//Specify your drive setup below. There are eight options:\n//ZERO_TRACKER_NO_ODOM, ZERO_TRACKER_ODOM, TANK_ONE_ENCODER, TANK_ONE_ROTATION, TANK_TWO_ENCODER, TANK_TWO_ROTATION, HOLONOMIC_TWO_ENCODER, and HOLONOMIC_TWO_ROTATION\n//For example, if you are not using odometry, put ZERO_TRACKER_NO_ODOM below:\nHOLONOMIC_TWO_ROTATION,\n\n//Add the names of your Drive motors into the motor groups below, separated by commas, i.e. motor_group(Motor1,Motor2,Motor3).\n//You will input whatever motor names you chose when you configured your robot using the sidebar configurer, they don\'t have to be "Motor1" and "Motor2".\n\n//Left Motors:\nmotor_group(LeftFront, LeftBack),\n\n//Right Motors:\nmotor_group(RightFront, RightBack),\n\n//Specify the PORT NUMBER of your inertial sensor, in PORT format (i.e. "PORT1", not simply "1"):\nPORT1,\n\n//Input your wheel diameter. (4" omnis are actually closer to 4.125"):\n3.25,\n\n//External ratio, must be in decimal, in the format of input teeth/output teeth.\n//If your motor has an 84-tooth gear and your wheel has a 60-tooth gear, this value will be 1.4.\n//If the motor drives the wheel directly, this value is 1:\n1.6,\n\n//Gyro scale, this is what your gyro reads when you spin the robot 360 degrees.\n//For most cases 360 will do fine here, but this scale factor can be very helpful when precision is necessary.\n360,\n\n/*---------------------------------------------------------------------------*/\n/*                                  PAUSE!                                   */\n/*                                                                           */\n/*  The rest of the drive constructor is for robots using POSITION TRACKING. */\n/*  If you are not using position tracking, leave the rest of the values as  */\n/*  they are.                                                                */\n/*---------------------------------------------------------------------------*/\n\n//PAUSE! The rest of the drive constructor is for robot using POSITION TRACKING.\n//If you are not using position tracking, leave the rest of the values as they are.\n\n//Input your drive motors by position. This is only necessary for holonomic drives, otherwise this section can be left alone.\n//LF:      //RF:    \nPORT15,     -PORT16,\n\n//LB:      //RB: \nPORT17,     -PORT18,\n\n//If you are using position tracking, this is the Forward Tracker port (the tracker which runs parallel to the direction of the chassis).\n//If this is a rotation sensor, leave it in "PORT1" format, inputting the port below.\n//If this is an encoder, enter the port as an integer. Triport A will be a "1", Triport B will be a "2", etc.\nPORT6,\n\n//Input the Forward Tracker diameter (reverse it to make the direction switch):\n2.75,\n\n//Input Forward Tracker center distance (a positive distance corresponds to a tracker on the right side of the robot, negative is left.)\n//This distance is in inches:\n-2,\n\n//Input the Sideways Tracker Port, following the same steps as the Forward Tracker Port:\nPORT3,\n\n//Sideways tracker diameter (reverse to make the direction switch):\n-2.75,\n\n//Sideways tracker center distance (positive distance is behind the center of the robot, negative is in front):\n5.5\n\n);\n'))),(0,n.kt)(i.Z,{value:"proto",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-cpp"},"Drive::Drive(enum::drive_setup drive_setup, motor_group DriveL, motor_group DriveR, int gyro_port, float wheel_diameter, float wheel_ratio, float gyro_scale, int DriveLF_port, int DriveRF_port, int DriveLB_port, int DriveRB_port, int ForwardTracker_port, float ForwardTracker_diameter, float ForwardTracker_center_distance, int SidewaysTracker_port, float SidewaysTracker_diameter, float SidewaysTracker_center_distance);\n")))))}m.isMDXComponent=!0}}]);